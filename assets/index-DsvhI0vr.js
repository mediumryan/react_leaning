import{c as S,o as A}from"./index-DE4h2VEI.js";import{h as d}from"./label-DahRaslS.js";import{b as f}from"./index-Djl51xko.js";const R=[["path",{d:"M12 7v14",key:"1akyts"}],["path",{d:"M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z",key:"ruj8y"}]],E=S("book-open",R),u="/react_leaning/assets/first-step-DrJ1TCiV.png",v="/react_leaning/assets/todo-sample-jp-BMW_2FKh.png",C="/react_leaning/assets/todo-sample-kr-Dc0_3aym.png",l="data:image/png;base64,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QJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERIkQECVCQJQIAVEiBESJEBAlQkCUCAFRIgREiRAQJUJAlAgBUSIERP0fIXI93alK4FEAAAAASUVORK5CYII=",m="data:image/png;base64,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",x="/react_leaning/assets/ref-error-Eje8sWur.png",b=[{id:"section1-orientation",section:1,order:0,title:"강의 시작하기: 무엇을 만들게 될까요?",type:0,exp:5,time:5,content:`# 🚀 환영합니다! React의 세계로

안녕하세요 👋 

 여러분은 이 강의를 통해 React.js에 대한 기초 지식을 갖추게 될 것입니다.

 본 강의는 **React를 처음 접하는 분들도** 직접 하나의 완성된 웹 애플리케이션을 만들어보는 것을 목표로 합니다.

---

### 🧠 수강 전 알아두면 좋아요

React를 배우기 전, 아래와 같은 **기본적인 웹 개발 지식** 을 알고 계시면 훨씬 수월합니다.

📌 **필요한 선수 지식**
> - 기본적인 **HTML 구조** (태그, 속성 등)
> - **JavaScript 기초 문법** (변수, 함수, 배열)

---

### 🎯 강의 컨셉

- React의 핵심 개념을 **직접 만들면서** 이해합니다.
- 복잡한 이론보다, **"왜 이렇게 쓰는지"** 실용성에 집중합니다.

---

### 🧩 최종 목표 미리보기

우리는 이번 강의를 통해 **Todo-List 애플리케이션** 을 밑바닥부터 직접 완성해볼 것입니다.

![Todo Sample](${C})

자, 그럼 시작해볼까요?`},{id:"intro-what-is-react",section:1,order:1,title:"React.js란 무엇인가?",type:0,exp:10,time:7,content:`# ⚛️ React: UI를 만드는 강력한 도구

**React** 는 사용자 인터페이스(UI)를 만들기 위한 **JavaScript 라이브러리** 입니다. Meta(구 Facebook)에서 개발하여 현재 가장 사랑받는 프론트엔드 기술이죠.

---

### 💡 왜 React인가요?

웹페이지에서 버튼을 클릭할 때, 화면 전체가 새로고침되지 않고 **필요한 부분만** 부드럽게 업데이트되는 경험을 해보셨나요? React는 이런 동적인 화면을 **효율적으로 구현** 하기 위해 태어났습니다.

---

### 📦 라이브러리 vs 프레임워크

많은 분이 헷갈려 하는 두 개념의 핵심은 **'누가 주도권을 가지고 있는가'** 입니다.

- **라이브러리** : 개발자가 필요할 때마다 **직접 골라서 쓰는 도구 모음** 입니다. 내가 원할 때 필요한 기능만 꺼내 쓸 수 있죠.
- **프레임워크** : 집을 지을 때 사용하는 **미리 짜인 틀** 입니다. 정해진 규칙과 흐름을 반드시 따라야 하며, 그 안에서 코드를 작성해야 합니다.



**"그래서 리액트는 라이브러리입니다!"**
React는 웹 전체를 관리하는 규칙을 강요하지 않습니다. 오직 **'UI를 만드는 도구'** 역할에 집중하죠. 
따라서 개발자가 원하는 다른 도구들과 **자유롭게 조합** 해서 사용할 수 있다는 것이 가장 큰 매력입니다.`},{id:"intro-spa-concept",section:1,order:2,title:"전체 페이지가 바뀌지 않는 이유 (SPA)",type:0,exp:10,time:5,content:`# 🪄 페이지가 바뀌지 않는 마법, SPA

React는 **SPA(Single Page Application)** 방식으로 동작합니다. 화면 전체가 '깜빡'이지 않고도 내용이 부드럽게 바뀌는 비밀이 바로 여기에 있습니다.

---

### 📌 SPA란 무엇일까요?

전통적인 웹사이트는 다른 페이지로 이동할 때마다 서버에서 전체 화면을 다시 받아옵니다. 하지만 SPA는
- 딱 **한 개의 페이지(HTML)** 만 로드합니다.
- 이후에는 JavaScript를 이용해 **필요한 데이터만** 바꿔 끼웁니다.

> **💡 SPA의 장점** 
> 1. 화면 깜빡임이 없어 **앱처럼 매끄러운 경험** 을 줍니다.
> 2. 서버 통신량이 줄어들어 **속도가 매우 빠릅니다.** `},{id:"quiz-react-definition",section:1,order:3,title:"React의 정의 퀴즈",type:2,question:"React는 JavaScript의 어떤 종류의 도구입니까? (ㄹㅇㅂㄹㄹ)",correctAnswer:"라이브러리,,Library",explanation:"React는 UI 구축을 위한 전용 기능을 제공하는 '라이브러리'입니다.",exp:20,time:3},{id:"intro-why-react",section:1,order:4,title:"왜 React를 배워야 할까요?",type:0,exp:10,time:6,content:`# 🌟 React를 배워야 하는 3가지 이유

전 세계 수많은 개발팀이 React를 선택하는 데에는 분명한 이유가 있습니다.

1. **컴포넌트 재사용** 
한 번 잘 만든 UI를 여기저기서 반복해서 쓸 수 있습니다.

2. **압도적인 생태계** 
모르는 것이 생겼을 때 물어볼 자료와 함께 쓸 도구들이 세상에서 가장 많습니다.

3. **선언적 프로그래밍** 
화면의 상태가 *어떻게* 변하는지 일일이 명령하지 않고, *무엇을* 보여줄지만 정하면 React가 알아서 그려줍니다.

> React를 배우는 것은 단순히 문법을 익히는 것이 아니라, **현대적인 개발자의 사고방식** 을 갖추는 과정입니다.`},{id:"app-creation-vite",section:1,order:5,title:"앱 생성하기 - Vite",type:0,exp:15,time:15,content:`# 🛠️ 실전! 첫 리액트 앱 만들기

이제 실제로 React 프로젝트를 생성해봅시다. 우리는 가장 빠르고 현대적인 도구인 **Vite** 를 사용합니다.

---

### ⌨️ 터미널 명령어를 순서대로 입력하세요

1️⃣ **프로젝트 생성** 
\`\`\`bash
npm create vite@latest my-todo-app -- --template react
\`\`\`

2️⃣ **프로젝트 폴더로 이동 및 도구 설치** 
\`\`\`bash
cd my-todo-app
npm install
\`\`\`

3️⃣ **개발 서버 실행** 
\`\`\`bash
npm run dev
\`\`\`

서버가 실행되면 터미널에 나온 주소를 브라우저에 입력해보세요. 여러분의 첫 React 화면이 나타납니다! \`http://localhost:5173\`

---

### 🧹 프로젝트 초기 설정 (청소하기)

Vite가 기본적으로 제공하는 예제 코드는 우리 프로젝트에 필요하지 않습니다. 깔끔하게 정리해 봅시다.

4️⃣ **불필요한 코드 및 파일 삭제** 
- **index.css** : 파일 내부의 모든 코드를 선택해서 삭제(비우기)하세요.
- **App.css** : 이 파일은 사용하지 않으므로 **파일 자체를 삭제** 합니다.
- **App.jsx** : 아래 코드만 남기고 모두 지워주세요.
\`\`\`jsx
function App() {

  return (
    <div>Hello, React!</div>
  )
}

export default App
\`\`\`

![Code Clean](${u})

5️⃣ **정리된 초기 화면 확인** 
위 작업을 모두 마쳤다면, 브라우저에는 아무런 스타일 없이 흰 바탕에 **Hello, React!** 라는 글자만 나타나게 됩니다. 이제 진짜 개발을 시작할 준비가 끝났습니다!

![Hello React](${l})
`},{id:"section1-summary",section:1,order:6,title:"섹션 1 정리: React의 큰 그림",type:0,exp:5,time:4,content:`# 🏁 섹션 1 정리

이번 섹션에서는 React를 시작하기 전에 꼭 알아야 할 **큰 그림** 을 살펴봤습니다.

---

### ✅ 이번 섹션에서 배운 것

- React는 UI를 만드는 **라이브러리** 다.
- **SPA** 방식을 통해 매끄러운 사용자 경험을 제공한다.
- **Vite** 를 이용해 빠르고 현대적인 개발 환경을 구축했다.

---

이제 준비운동은 끝났습니다. 

다음 섹션부터는 React의 핵심인 **컴포넌트와 JSX** 를 직접 다뤄보며 코드를 작성해보겠습니다! 🚀`},{id:"basic-understanding-components",section:2,order:0,title:"컴포넌트(Components) 이해하기",type:0,exp:10,time:6,content:`# 🧱 UI의 조각, 컴포넌트(Component)

**컴포넌트** 는 UI를 구성하는 **독립적이고 재사용 가능한 블록** 입니다. 마치 레고 블록을 조립하듯 웹사이트를 만들 수 있게 해주죠.

---

### 💻 React 컴포넌트는 사실 함수입니다

가장 기본적인 형태의 컴포넌트는 **JavaScript 함수** 입니다.

\`\`\`jsx
function Welcome() {
  return <h1>안녕, 리액트!</h1>;
}
\`\`\`

이렇게 만든 컴포넌트는 마치 HTML 태그처럼 사용할 수 있습니다.

\`\`\`jsx
<Welcome />
\`\`\`

---

### 🧠 컴포넌트를 함수로 이해해봅시다

> 📌 **입력값을 받아서 → 화면(UI)을 반환하는 함수** 
- 입력값: props (데이터)
- 반환값: 화면에 보여질 JSX

즉, React에서는 **함수로 화면을 만든다** 고 생각해도 괜찮습니다.

> ⚠️ **주의**
> 컴포넌트 이름의 첫 글자는 반드시 **대문자** 여야 합니다. 
> 소문자로 시작하면 React는 이를 일반 HTML 태그로 인식해버립니다.`},{id:"basic-jsx-syntax",section:2,order:1,title:"JSX: 자바스크립트 속 HTML",type:0,exp:10,time:10,content:`# 🏗️ JavaScript 확장 문법, JSX

**JSX** 는 **자바스크립트 안에서 HTML처럼 보이는 문법** 을 사용할 수 있게 해주는 React의 핵심 문법입니다.

---

### ❓ JSX는 왜 필요할까요?

JSX가 없다면 우리는 일일이 복잡한 자바스크립트 함수를 호출해야 합니다.

\`\`\`js
// JSX 없이 작성할 때
React.createElement('h1', null, '안녕하세요');
\`\`\`

---

### 🔀 자바스크립트 값 섞어 쓰기 

 JSX의 강력함은 자바스크립트의 변수를 **중괄호** \`{ }\`를 통해 화면에 바로 뿌릴 수 있다는 점입니다.

\`\`\`jsx
function App() {
  const name = '철수';
  const age = 20;

  return <h2>{name}님은{age}살입니다.</h2>;
}
\`\`\`

**🖥️ 브라우저 출력 결과:** 
> **철수님은 20살입니다.** 
 
이렇게 중괄호 안의 자바스크립트 변수가 실제 데이터로 치환되어 화면에 나타납니다.`},{id:"basic-jsx-rules",section:2,order:2,title:"JSX 작성 시 꼭 지켜야 할 규칙",type:0,exp:15,time:8,content:`# 📏 JSX를 사용할 때 지켜야 할 3가지 약속

JSX는 HTML과 비슷하게 생겼지만, 실제로는 자바스크립트이기 때문에 몇 가지 엄격한 규칙이 있습니다.

### 1️⃣ 반드시 하나의 태그로 감싸기
두 개 이상의 태그를 나열할 때는 반드시 부모 태그로 감싸야 합니다. 이름 없는 태그인\`<> ... </>\` **Fragment** 를 사용하면 불필요한 div를 줄일 수 있습니다.

\`\`\`jsx
return (
  <>
    <h1>제목</h1>
    <p>내용</p>
  </>
);
\`\`\`

### 2️⃣ class가 아니라 className
자바스크립트에서 \`class\`라는 단어는 이미 주인이 있는 단어입니다. 따라서 CSS 클래스를 줄 때는 **className** 을 사용합니다.

\`\`\`jsx
<div className="header">메뉴</div>
\`\`\`

### 3️⃣ 모든 태그는 닫혀야 합니다

 \`\`\`jsx
<img> 
 <input>
\`\`\` 

 위의 두 태그와 같이 HTML에서 닫지 않던 태그들도 JSX에서는 반드시 \`<img />\`와 같이 **Self-closing** 하거나 닫아주어야 합니다.`},{id:"quiz-jsx-definition",section:2,order:3,title:"JSX의 개념 퀴즈",type:1,exp:20,time:3,question:"다음 중 JSX에 대한 설명으로 가장 올바른 것은 무엇입니까?",options:["HTML 파일을 대체하기 위한 새로운 언어","브라우저에서 직접 실행되는 템플릿 언어","자바스크립트 안에서 HTML처럼 보이는 문법을 사용할 수 있게 해주는 문법","React 전용의 스타일링 문법"],correctAnswerIndex:2,explanation:"JSX는 JavaScript XML의 약자로, 코드의 가독성을 높여주는 자바스크립트 확장 문법입니다."},{id:"quiz-jsx-expression",section:2,order:4,title:"JSX 표현식 퀴즈",type:1,exp:20,time:3,question:"JSX 안에서 자바스크립트 변수를 출력할 때 사용하는 올바른 방법은 무엇입니까?",options:["<p>name</p>","<p>${name}</p>","<p>{name}</p>","<p>(name)</p>"],correctAnswerIndex:2,explanation:"JSX 내부에서 자바스크립트 변수나 표현식을 사용할 때는 반드시 중괄호 { }를 사용해야 합니다."},{id:"quiz-jsx-statement-vs-expression",section:2,order:5,title:"JSX 문법 이해 퀴즈",type:1,exp:25,time:4,question:"다음 중 JSX 안에서 직접 사용할 수 없는 것은 무엇입니까?",options:["삼항 연산자 (condition ? A : B)","숫자 계산 (1 + 2)","if 문","변수 값 출력"],correctAnswerIndex:2,explanation:"JSX 내의 중괄호에는 결과값이 즉시 반환되는 '표현식'만 올 수 있습니다. if문은 '문(statement)'이므로 중괄호 내부에서 직접 사용할 수 없습니다."},{id:"section2-summary",section:2,order:6,title:"섹션 2 정리: 컴포넌트와 JSX",type:0,exp:5,time:4,content:`# 🏁 섹션 2 마무리

고생하셨습니다! 이제 여러분은 리액트 앱의 기초 뼈대를 세우는 방법을 배웠습니다.

---

### ✅ 핵심 요약
- **컴포넌트** 는 UI의 최소 단위이며, 이름은 **대문자** 로 시작한다.
- **JSX** 는 자바스크립트와 HTML의 만남이다.
- JSX는 반드시 **하나의 부모** 태그로 감싸야 하며, **className** 을 사용한다.

---

이제 뼈대를 만들었으니, 여기에 **'생명력(데이터의 변화)'을** 불어넣을 차례입니다. 
다음 섹션인 **State** 에서 만나요! 🚀`},{id:"state-what-is-state",section:3,order:0,title:"State란 무엇인가?",type:0,exp:15,time:8,content:`# 🧠 컴포넌트의 기억 장치, State

React에서 **State** 는 컴포넌트가 내부적으로 **기억하고 있는 값** 입니다. 
사용자와의 상호작용에 따라 언제든 **변경될 수 있는 데이터** 를 의미하죠.

---

### ❓ 왜 일반 변수로는 화면이 안 바뀔까요?

\`\`\`jsx
let count = 0;

function Counter() {
  const increase = () => {
    count = count + 1;
    console.log(count); // 값은 올라가지만 화면은 그대로!
  };

  return (
    <div>
      <p>{count}</p>
      <button onClick={increase}>증가</button>
    </div>
  );
}
\`\`\`

일반 변수는 값이 바뀌어도 **React가 화면을 다시 그려야 한다는 사실을 알지 못합니다.** 즉, 컴포넌트를 **렌더링** 하지 않기 때문입니다.

---

### ✅ 그래서 State가 필요합니다

State는 단순한 데이터가 아니라, **"값이 바뀌었으니 화면을 다시 그려줘(렌더링해줘)!"** 라고 React에게 보내는 신호입니다.

> 📌 **여기서 '렌더링(Rendering)'이란?**
> 컴포넌트 함수가 다시 호출되고, 그 결과로 변경된 데이터가 반영된 **새로운 화면(UI)이 브라우저에 그려지는 과정** 을 말합니다.

State가 변경되면 React는 자동으로 이 렌더링 과정을 수행하여 사용자가 바뀐 값을 볼 수 있게 합니다.`},{id:"state-counter-practice",section:3,order:1,title:"카운터 앱 실습: useState 사용법",type:0,exp:25,time:10,content:`# 🛠️ useState로 숫자 바꾸기

이제 실제로 화면을 바꾸는 코드를 작성해봅시다. 리액트에서 제공하는 \`useState\` 도구를 사용합니다.

\`\`\`jsx
import { useState } from 'react'; // 👈 꼭 불러와야 해요!

function Counter() {
  // [현재값, 변경함수] = useState(초기값);
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>현재 숫자: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}
\`\`\`

**🖥️ 브라우저 출력 결과:** 
> 현재 숫자: 0  
> [증가 버튼]

**🔄 버튼을 누르면 일어나는 일:** 
1. \`setCount\` 함수가 실행되어 \`count\` 가 변경됩니다.
2. React가 "어? count가 바뀌었네?"라고 감지합니다.
3. **컴포넌트를 다시 실행(재렌더링)** 하여 화면에 새로운 숫자를 그립니다.`},{id:"quiz-state-description",section:3,order:2,title:"State 개념 이해 퀴즈",type:2,question:"컴포넌트가 기억하고 있으며, 값이 변경되면 화면이 다시 렌더링되도록 만드는 React의 데이터는 무엇입니까?",correctAnswer:"State,,state,,스테이트,,상태,,상태값",explanation:"State는 컴포넌트 내부에서 변할 수 있는 값을 관리하며, 변경 시 렌더링을 유발합니다.",exp:20,time:3},{id:"quiz-state-update-code",section:3,order:3,title:"State 변경 코드 퀴즈",type:2,question:`다음 상태가 선언되어 있을 때, number의 값을 5로 변경하는 함수 호출 코드를 작성하세요.

const [number, setNumber] = useState(0);`,correctAnswer:"setNumber(5)",explanation:"상태 변경 함수인 setNumber에 원하는 값을 인자로 전달합니다.",exp:30,time:4},{id:"quiz-state-change-effect",section:3,order:4,title:"State 변경 결과 퀴즈",type:1,question:"State의 값이 변경되면 React 컴포넌트에는 어떤 일이 발생합니까?",options:["아무 일도 일어나지 않는다","전체 페이지가 새로고침된다","해당 컴포넌트가 다시 렌더링된다","에러가 발생한다"],correctAnswerIndex:2,explanation:"React는 State의 변화를 감지하여 해당 컴포넌트를 재렌더링합니다.",exp:20,time:3},{id:"state-common-mistakes",section:3,order:5,title:"+ State에서 가장 많이 하는 실수들",type:0,exp:20,time:15,content:`# ⚠️ 초보자가 가장 자주 하는 State 실수

### 1️⃣ State를 직접 수정하지 마세요
\`\`\`jsx
// ❌ 절대 안 돼요!
count = count + 1;

// ✅ 항상 이렇게 하세요
setCount(count + 1);
\`\`\`
직접 수정하면 React는 값이 바뀐 줄 모르고 화면을 그대로 둡니다.

### 2️⃣ State는 '다음 렌더링'에 바뀝니다
\`\`\`jsx
setCount(count + 1);
console.log(count); // 🧐 여전히 이전 값이 찍힐 거예요!
\`\`\`
\`setCount\` 를 실행하자마자 값이 바뀌는 게 아니라, **재렌더링이 완료되어야** 새로운 값이 적용됩니다.

### 3️⃣ 모든 값을 State로 만들지 마세요
바뀌었을 때 **화면(UI)도 같이 바뀌어야 하는 값** 만 State로 만드세요. 
그렇지 않은 값은 일반 변수로 충분합니다.

 \`\`\`jsx
 const
 let 
\`\`\` `},{id:"section3-summary",section:3,order:6,title:"Section 3 마무리: State 한 번에 정리하기",type:0,exp:15,time:6,content:`# 🏁 섹션 3 마무리

축하합니다! 이제 리액트의 가장 중요한 심장인 **State** 를 마스터하셨습니다.

---

### ✅ 핵심 요약
- **State** 는 컴포넌트의 기억 장치다.
- 상태 변경은 반드시 **전용 함수(setter)** 를 사용해야 한다.
- 상태가 바뀌면 **재렌더링** 이 일어난다.

---

이제 나의 컴포넌트가 데이터를 가질 수 있게 되었습니다. 
그렇다면 이 데이터를 **다른 컴포넌트에게 전달** 하려면 어떻게 해야 할까요? 
다음 섹션인 **Props** 에서 확인해봅시다! 🎁`},{id:"props-passing-data",section:4,order:0,title:"Props로 데이터 전달하기",type:0,exp:20,time:12,content:`# 🎁 컴포넌트에게 주는 선물, Props

React에서 **Props** 는 부모 컴포넌트가 자식 컴포넌트에게 전달하는 **데이터** 입니다. 

> 쉽게 말해, 부모가 자식에게 주는 **읽기 전용 값** 입니다.

---

### ❓ 왜 Props가 필요할까요?

웹사이트는 수많은 컴포넌트의 조립으로 만들어집니다. 

 이때 컴포넌트끼리 서로 정보를 주고받아야 화면이 완성되는데, 그 통로 역할을 하는 것이 바로 Props입니다.

---

### 👨‍👩‍👧 부모 → 자식 구조 이해하기

\`\`\`jsx
// 부모 컴포넌트 (App.jsx)
function App() {
  return <MyButton text="저장하기" />;
}

// 자식 컴포넌트 (MyButton.jsx)
function MyButton(props) {
  return <button>{props.text}</button>;
}
\`\`\`

**🖥️ 브라우저 출력 결과:** 
> [저장하기]

 \`props.text\` 부모(App)가 보낸 "저장하기"라는 값을 자식이 받아서 사용합니다.
 자식 컴포넌트는 이 값을 **사용만 할 수 있고, 직접 수정할 수는 없습니다.** `},{id:"props-destructuring-intro",section:4,order:1,title:"Props를 더 간단하게 받는 방법",type:0,exp:10,time:10,content:`# ✨ 더 깔끔한 코드, 구조 분해 할당

매번 \`props.ooo\` 라고 쓰는 대신, JavaScript의 **구조 분해 할당** 문법을 쓰면 코드가 훨씬 간결해집니다.

---

### 🔄 어떻게 바뀌나요?

**기존 방식** 
\`\`\`jsx
function MyButton(props) {
  return <button>{props.text}</button>;
}
\`\`\`

**구조 분해 할당 방식** 
\`\`\`jsx
function MyButton({ text }) {
  return <button>{text}</button>;
}
\`\`\`

---

### 🚀 Props가 많을수록 강력해집니다

예를 들어 부모로부터 받은 Props가 **100개, 1000개** 라고 가정해 보세요. 구조 분해 할당을 쓰지 않는다면 여러분은 각각의 데이터를 사용할 때마다 매번 **props.** 를 앞에 붙여야 할 것입니다.



- **가독성 저하** : 코드가 불필요하게 길어져 한눈에 들어오지 않습니다.
- **개발 피로도** : 매번 **props.** 를 타이핑하는 과정은 매우 번거롭고 실수하기 쉽습니다.

**반면에 구조 분해 할당을 사용하면?**
\`\`\`jsx
// props. 를 쓸 필요가 없어집니다!
function UserProfile({ name, age, email, address, job, hobby }) {
  return (
    <div>
      <h1>{name}</h1>
      <p>{age}세 / {job}</p>
      <span>{email}</span>
    </div>
  );
}
\`\`\`

이처럼 함수의 매개변수 자리에 직접 \`{ }\` 를 적어주면, 마치 내 방에 있는 물건을 바로 꺼내 쓰듯 데이터 이름만으로 간편하게 사용할 수 있습니다. 읽기 편하고 쓰기 쉬운 코드를 만드는 가장 첫 걸음입니다!`},{id:"props-pass-setstate",section:4,order:2,title:"함수도 Props로 전달할 수 있어요",type:0,exp:20,time:15,content:`# ⚡ 부모의 함수를 자식에게 전달하기

Props로는 글자나 숫자뿐만 아니라 **함수도 전달할 수 있습니다.** 부모가 가진 State를 자식 쪽에서 바꾸고 싶을 때 이 방식을 사용합니다.

---

### ⌨️ 예제로 살펴보기

\`\`\`jsx
// 부모 컴포넌트
function App() {
  const [count, setCount] = useState(0);
  
  return <CounterButton onIncrease={() => setCount(count + 1)} />;
}

// 자식 컴포넌트
function CounterButton({ onIncrease }) {
  return <button onClick={onIncrease}>증가</button>;
}
\`\`\`

- **데이터 관리**: 부모(App)가 담당
- **행동(클릭)**: 자식(CounterButton)이 담당
- 자식에서 버튼을 누르면 부모가 준 함수가 실행되어 부모의 State가 바뀝니다!`},{id:"props-common-mistakes",section:4,order:3,title:"+ Props 사용 시 주의할 점",type:0,exp:10,time:8,content:`# ⚠️ Props 사용 시 자주 하는 실수

### 1️⃣ Props를 직접 수정하지 마세요
\`\`\`jsx
function Child(props) {
  props.text = "변경"; // ❌ 에러 발생!
  return <div>{props.text}</div>;
}
\`\`\`
Props는 부모가 주는 '선물'과 같아서 자식이 마음대로 바꿀 수 없습니다. 값을 바꾸고 싶다면 부모에게 요청(함수 실행)해야 합니다.

### 2️⃣ Props와 State 구분하기
- **컴포넌트 스스로** 값을 만들고 관리한다면? 👉 **State** 
- **부모로부터** 값을 받아서 보여주기만 한다면? 👉 **Props** 
### 3️⃣ 문자열 외의 값은 중괄호 { } 사용
\`\`\`jsx
<MyButton text="저장" /> // 문자열은 따옴표
<Counter count={10} /> // 숫자, 변수, 함수는 중괄호
\`\`\` `},{id:"quiz-props-definition",section:4,order:4,title:"Props의 정의 퀴즈",type:1,question:"다음 중 Props의 올바른 설명은 무엇일까요?",options:["컴포넌트가 스스로 관리하는 상태 값","부모 컴포넌트가 자식에게 전달하는 읽기 전용 데이터","자식 컴포넌트가 직접 수정할 수 있는 값","HTML 태그 속성을 의미하는 React 전용 문법"],correctAnswerIndex:1,explanation:"Props는 상위(부모) 컴포넌트가 하위(자식) 컴포넌트에게 전달하는 읽기 전용 데이터입니다.",exp:20,time:5},{id:"quiz-props-vs-state",section:4,order:5,title:"Props와 State 구분하기",type:2,question:"컴포넌트가 직접 관리하며 변경 시 렌더링을 유발하는 값은 무엇인가요? (Props 또는 State)",correctAnswer:"State,,state,,스테이트,,상태,,상태값",explanation:"State는 컴포넌트 내부 상태이며, Props는 외부로부터 받는 설정값입니다.",exp:20,time:5},{id:"props-summary-review",section:4,order:6,title:"Props 마무리 & 복습",type:0,exp:15,time:10,content:`# 🏁 섹션 4 마무리

이제 여러분은 컴포넌트끼리 대화하는 법을 배웠습니다! 

---

### ✅ 핵심 요약
- **Props** 는 부모가 자식에게 주는 **데이터** 다.
- 자식은 Props를 **수정할 수 없다.** (읽기 전용)
- **함수** 도 Props로 넘겨서 자식이 부모의 상태를 바꾸게 할 수 있다.
- \`{ text }\` 처럼 **구조 분해 할당** 을 쓰면 코드가 깔끔해진다.

---

부모로부터 함수를 전달받는 법까지 알게 되었으니, 이제 그 함수를 '언제' 실행할지 결정할 차례입니다. 
사용자의 클릭이나 입력에 반응하는 방법! 다음 섹션인 **이벤트(Event)** 에서 만나요! ⚡`},{id:"event-what-is-event",section:5,order:0,title:"React에서 이벤트(Event)란?",type:0,exp:15,time:8,content:`# ⚡ 사용자와의 소통, 이벤트(Event)

React에서 **이벤트** 란 사용자가 화면과 상호작용할 때 발생하는 모든 행동을 의미합니다. 

### ❓ 이벤트는 왜 중요한가요?

사용자가 버튼을 누르거나 글자를 입력할 때 화면이 반응하게 만들려면 반드시 이벤트를 가로채야 합니다.

> **사용자의 행동** → 이벤트 발생 → 함수 실행 → **State 변경** → 화면 업데이트

이 흐름의 시작점이 바로 이벤트입니다.

---

### 📌 React 이벤트의 특징

- HTML 이벤트와 비슷하지만, **카멜 케이스(camelCase)** 를 사용합니다.
- 문자열이 아닌 **함수 그 자체** 를 전달합니다.

\`\`\`jsx
<button onClick={handleClick}>클릭</button>
\`\`\` `},{id:"event-html-vs-react",section:5,order:1,title:"HTML 이벤트와 React 이벤트의 차이",type:0,exp:15,time:7,content:`# 🆚 HTML vs React 이벤트

React 이벤트는 HTML과 비슷해 보이지만 작성 방식이 엄격히 다릅니다.

### ❌ HTML 방식 (문자열 전달)
\`\`\`html
<button onclick="handleClick()">클릭</button>
\`\`\`

### ✅ React 방식 (함수 전달)
\`\`\`jsx
<button onClick={handleClick}>클릭</button>
\`\`\`

---

### 🧠 핵심 차이점

 **이름 규칙** 
 \`\`\`jsx
 //대문자 주의!
 onclick ❌
 onClick ✅
\`\`\`

 **전달 방식** \`"onClick"\` 따옴표 안에 코드를 적는 게 아니라, \`{onClick}\` 중괄호 안에 **함수 이름** 을 넣습니다.

> React는 "이 버튼이 클릭되면 **이 함수를 나중에 실행해줘**"라고 부탁하는 방식입니다.`},{id:"event-handler-function",section:5,order:2,title:"이벤트 핸들러 함수 만들기",type:0,exp:20,time:10,content:`# 🛠️ 이벤트 핸들러(Event Handler)

이벤트가 발생했을 때 실행되는 함수를 **이벤트 핸들러** 라고 부릅니다.

\`\`\`jsx
function App() {
  const handleClick = () => {
    alert('버튼이 클릭되었습니다!');
  };
  return <button onClick={handleClick}>알림 띄우기</button>;
}
\`\`\`

**🖥️ 브라우저 출력 결과:** 
> [알림 띄우기] 버튼(클릭 시 브라우저 알림창 등장)

---

### 💡 함수 이름 짓기 팁
이벤트 핸들러의 이름은 

\`\`\`jsx
 handleClick
 onChangeName
 handleSubmit 
\`\`\`

 위와 같이 **어떤 동작을 하는지** 명확하게 짓는 것이 관습입니다.`},{id:"event-function-vs-execution",section:5,order:3,title:"함수를 전달할까? 실행할까?",type:0,exp:20,time:12,content:`# ⚠️ 가장 많이 하는 실수: 함수 호출 금지!

React 이벤트를 작성할 때 가장 흔히 저지르는 실수입니다.

### ❌ 잘못된 코드
\`\`\`jsx
<button onClick={handleClick()}>클릭</button>
\`\`\`
이것은 클릭했을 때 실행되는 게 아니라, **화면이 그려지자마자 함수가 즉시 실행** 되어 버립니다.

### ✅ 올바른 코드
\`\`\`jsx
<button onClick={handleClick}>클릭</button>
\`\`\`
함수 뒤에 \`()\` 를 붙이지 않고 이름만 전달해야 합니다.

---

### 💡 화살표 함수(Arrow Function)를 쓰면 실행 코드를 넣어도 돼요!

"그래도 저는 함수 안에 다른 코드나 인자를 넣어서 실행하고 싶은데요?" 라는 의문이 생길 수 있습니다. 현업에서도 이럴 때 **화살표 함수(Arrow Function)** 를 정말 많이 사용합니다.

\`\`\`jsx
<button 
  onClick={() => { 
    console.log("안녕!"); 
    handleClick(); 
  }}
>
  클릭
</button>
\`\`\`

**왜 이건 되나요?**
\`() => { ... }\` 형태의 **화살표 함수(Arrow Function)** 자체는 아직 실행되지 않은 **'새로운 함수 정의'** 이기 때문입니다. 



- **handleClick()** : 함수를 즉시 실행하고 그 결과값을 onClick에 전달합니다. (화면이 뜨자마자 실행됨!)
- **() => { ... }** : "나중에 이 **화살표 함수(Arrow Function)** 가 호출되면, 그때 안에 있는 코드를 실행해줘!" 라는 **함수 주머니** 를 전달하는 것과 같습니다.

> 📌 **요약** : 함수 이름만 쓰거나, **화살표 함수(Arrow Function)** 로 감싸서 전달하세요. 그것이 리액트에서의 올바른 **'실행 예약'** 방법입니다!`},{id:"event-state-update",section:5,order:4,title:"이벤트로 State 변경하기",type:0,exp:25,time:12,content:`# 🔄 이벤트와 State의 만남

이벤트의 진정한 목적은 사용자의 입력을 받아 **State를 바꾸는 것** 입니다.

\`\`\`jsx
function Counter() {
  const [count, setCount] = useState(0);
  const handleIncrease = () => {
    setCount(count + 1); 
  };
  return (
    <div>
      <p>값: {count}</p>
      <button onClick={handleIncrease}>더하기</button>
    </div>
  );
}
\`\`\`

**🖥️ 브라우저 출력 결과** 
> 값: 0  
> [더하기] 클릭 시 숫자가 1씩 증가`},{id:"quiz-event-camelcase",section:5,order:5,title:"React 이벤트 문법 퀴즈",type:1,exp:20,time:5,question:"React에서 버튼 클릭 이벤트를 올바르게 작성한 것은 무엇인가요?",options:['onclick="handleClick()"',"onClick={handleClick}",'onClick="handleClick"',"onclick={handleClick()}"],correctAnswerIndex:1,explanation:"React 이벤트는 카멜 케이스(onClick)를 사용하며, 중괄호 안에 함수 이름을 전달합니다."},{id:"quiz-event-short-answer",section:5,order:6,title:"이벤트 개념 단답 퀴즈",type:2,exp:20,time:5,question:"React 이벤트 핸들러에 전달해야 하는 것은 함수의 '실행 결과'일까요, '함수 그 자체'일까요?",correctAnswer:"함수,,함수 그 자체,,function,,function itself",explanation:"이벤트가 발생했을 때 비로소 실행되도록 함수 자체를 넘겨주어야 합니다."},{id:"event-summary-review",section:5,order:7,title:"Section 5 마무리: 이벤트 정리",type:0,exp:15,time:7,content:`# 🏁 섹션 5 마무리

이제 여러분은 사용자의 클릭에 반응하는 생동감 있는 컴포넌트를 만들 수 있습니다!

### ✅ 핵심 요약
- React 이벤트는 **camelCase** 를 사용한다 \`onClick\`
- 이벤트 핸들러에는 **함수 이름** 만 전달한다. \`onClick={handleClick}\`
- 이벤트를 통해 **State를 변경** 하면 화면이 다시 그려진다.

---

다음 섹션에서는 여러 개의 데이터를 한 번에 다루는 법과 **불변성(Immutable)** 에 대해 알아보겠습니다. 

이제 본격적으로 데이터를 다루는 법을 배울 시간입니다! 🚀`},{id:"list-intro",section:6,order:0,title:"List와 Object 기초 이해하기",type:0,exp:10,time:5,content:`# 📦 데이터를 묶는 방법: 배열과 객체

React 앱에서 다루는 대부분의 데이터는 **배열(List)** 과 **객체(Object)** 형태입니다. 

### 1️⃣ 무엇이 다른가요?
- **배열(List)** : [사과, 바나나, 딸기] 처럼 **순서** 가 있는 데이터 묶음입니다.
\`[사과, 바나나, 딸기]\`
- **객체(Object)** : { 이름: '철수', 나이: 20 } 처럼 **의미(Key)** 가 있는 데이터 묶음입니다.
\`{ 이름: '철수', 나이: 20 }\`

---

### 2️⃣ React에서 왜 중요할까요?
- **배열** : 투두 리스트의 목록처럼 **반복되는 화면** 을 만들 때 사용합니다.
- **객체** : 한 명의 사용자 정보처럼 **복합적인 데이터** 를 관리할 때 사용합니다.`},{id:"list-render",section:6,order:1,title:"배열 데이터를 화면에 반복 렌더링하기",type:0,exp:15,time:12,content:`# 🔄 반복문의 리액트 버전: map()

배열을 화면에 뿌릴 때는 자바스크립트의 **\`map()\`** 함수를 사용합니다.

### ✅ 예시 
\`\`\`jsx
{fruits.map((fruit, index) => {
  return (
    <li key={index}>
      {fruit}
    </li>
  );
})}
\`\`\`

---

### 📌 왜 key 속성이 필수인가요?

React는 **key** 를 보고 "아, 이 항목이 수정됐구나"를 판단합니다. 마치 우리 각자에게 부여된 **주민등록번호** 와 같죠.



 **💡 꿀팁: 진짜 고유 ID는 어떻게 생겼나요?** 
> 연습 중에는 **index** 를 쓰기도 하지만, 실제 서비스에서는 아래와 같이 **절대 겹치지 않는 고유한 값** 을 사용합니다.
> - **데이터베이스 ID**
  \`"user_01" \` \` "post_99" \`
> - **랜덤 문자열**
  \` "abc-123-def" \`
> - **시간값(생성된 찰나의 시간)**
  \` Date.now() \` 

> 단순히 **1, 2, 3...** 처럼 순서대로 매겨지는 숫자(**index**) 는 리스트의 순서가 뒤바뀌면 React가 어떤 항목이 진짜 바뀌었는지 찾지 못해 **버그의 원인** 이 됩니다! `},{id:"list-reference-concept",section:6,order:2,title:"객체와 배열: 메모리 주소(참조)의 비밀",type:0,exp:15,time:10,content:`# 🔗 왜 직접 수정하면 안 될까요? (참조 이해하기)

리액트가 State가 바뀌었는지 확인하는 방법은 의외로 단순합니다. **"이전 주소와 지금 주소가 똑같은가?"** 를 비교하죠.

### 1️⃣ 일반 변수 vs 객체/배열
- **일반 변수(숫자, 문자)** : 값이 바뀌면 리액트가 바로 알아챕니다.
- **객체/배열** : 실제 데이터가 아닌, 데이터가 저장된 **'메모리 주소(참조)'** 를 변수에 담고 있습니다.

### 2️⃣ 리액트가 변화를 모르는 이유
\`\`\`javascript
const [user, setUser] = useState({ name: '철수' });

user.name = '영희'; // ❌ 데이터는 바뀌었지만, '주소'는 그대로입니다.
setUser(user);    // 🧐 리액트: "주소가 똑같네? 아무것도 안 바뀌었구나!"
\`\`\`

### 💡 결론
리액트를 깨우려면 안의 내용물만 바꾸는 게 아니라, **새로운 주소(새로운 객체)** 를 만들어서 통째로 갈아 끼워줘야 합니다. 이때 필요한 도구가 바로 **스프레드 연산자** 입니다.`},{id:"state-array-copy",section:6,order:3,title:"스프레드 연산자(...): 새로운 참조 만들기",type:0,exp:15,time:12,content:`# ✨ 복사해서 새로 만들기: 스프레드 연산자(...)

'참조의 문제'를 해결하는 가장 깔끔한 방법입니다. 기존 데이터를 그대로 복사해 **새로운 주소를 가진 복제본** 을 만드는 것이죠.

### 🔹 배열 업데이트 패턴
\`\`\`jsx
const [todos, setTodos] = useState(['우유']);

// [...기존배열, 새항목] -> 기존 것을 펼쳐서 새 배열에 담기!
setTodos([...todos, '공부']); 
\`\`\`

### 🔹 객체 업데이트 패턴
\`\`\`jsx
const [user, setUser] = useState({ name: '철수', age: 20 });

// { ...기존객체, 수정할속성 } -> 나머지는 복사하고 age만 덮어쓰기!
setUser({ ...user, age: 21 });
\`\`\`

**🖥️ 브라우저 결과** 
> 메모리 주소(참조)가 바뀌었으므로 리액트가 즉시 감지하고 화면을 **재렌더링** 합니다.`},{id:"state-immutability",section:6,order:4,title:"불변성(Immutable)과 상태 관리",type:0,exp:15,time:8,content:`# 🛡️ 데이터를 지키는 원칙, 불변성

**불변성** 이란 상태를 직접 변경하지 않는 원칙을 말합니다. 

### ❓ 직접 수정하면 안 되는 이유
React는 이전 데이터와 새 데이터의 **메모리 주소(참조)** 를 비교합니다. 
주소가 바뀌지 않으면 데이터가 변했다고 판단하지 않아 화면을 다시 그리지 않습니다.

---

### 🛠️ 불변성을 지켜주는 도구 모음

리액트 상태 업데이트 시, 아래 도구들은 기존 배열을 건드리지 않고 **새로운 배열을 반환** 하므로 안심하고 사용할 수 있습니다.

**1️⃣ 스프레드 연산자**
\`\`\`javascript
[...] // 기존 배열 복사 및 항목 추가
{...} // 기존 객체 복사 및 속성 수정
\`\`\`

**2️⃣ 얕은 복사본을 반환하는 주요 메서드**
\`\`\`javascript
.map()    // 모든 요소를 변형하여 새 배열 생성
.filter() // 조건에 맞는 요소만 골라내어 새 배열 생성
.concat() // 여러 배열을 합쳐서 새 배열 생성
.slice()  // 배열의 일부분을 잘라내어 새 배열 생성

// (최신 문법) 원본을 바꾸지 않는 정렬과 역순
.toSorted()
.toReversed()
\`\`\`

---

### ✅ 핵심 요약

 기존 데이터를 직접 수정하는 

\`\`\`jsx
 push   // 데이터 추가 
 splice // 데이터 추가 / 삭제 
 sort   // 데이터 정렬 
\`\`\`

 등은 리액트에서 잠시 잊어주세요! 
항상 위 도구들을 활용해 **새 복사본** 을 만들어 **setState** 에 전달하는 것이 리액트의 정석입니다.`},{id:"quiz-list-map",section:6,order:5,title:"배열 렌더링 퀴즈",type:2,question:"React에서 배열을 화면에 반복 렌더링할 때 사용하는 JavaScript 메서드의 이름을 쓰세요.",correctAnswer:"map,,map(),,맵",explanation:"map() 함수는 배열의 각 요소를 돌며 JSX 엘리먼트로 변환해주는 역할을 합니다.",exp:10,time:3},{id:"quiz-immutability-reason",section:6,order:6,title:"불변성 원리 퀴즈",type:1,question:"객체나 배열을 직접 수정했을 때 리액트가 화면을 다시 그리지 않는 이유는 무엇인가요?",options:["자바스크립트 엔진에 에러가 발생해서","리액트는 값이 아닌 메모리 주소(참조)의 변화를 감지하기 때문에","직접 수정하면 데이터가 삭제되기 때문에","리액트가 객체를 싫어하기 때문에"],correctAnswerIndex:1,explanation:"리액트는 이전 상태와 새로운 상태의 참조(주소)가 다를 때만 업데이트를 수행합니다.",exp:20,time:5},{id:"list-summary-review",section:6,order:7,title:"Section 6 마무리: 리스트와 불변성",type:0,exp:20,time:7,content:`# 🏁 섹션 6 정리

리액트 개발자라면 평생 지켜야 할 **'불변성'** 의 기초를 마스터하셨습니다!

### ✅ 핵심 포인트
- **map()** 으로 리스트를 그리고, **key** 를 꼭 부여하자.
- 객체/배열은 **메모리 주소(참조)** 를 가진다.
- **스프레드(...)** 연산자로 항상 **새로운 주소** 를 가진 복사본을 만들어 State를 업데이트하자.

---

이제 여러 데이터를 다루는 법까지 알게 되었습니다. 

데이터를 보여주는 법을 배웠으니, 이제 사용자로부터 데이터를 **'입력'** 받는 법을 배울 차례입니다. 
투두 리스트의 핵심 기능! 다음 섹션인 **Section 7: Form 이벤트** 에서 만나요! 🚀`},{id:"form-intro",section:7,order:0,title:"왜 Form 이벤트를 배워야 할까요?",type:0,exp:10,time:5,content:`# 📝 입력의 시작, Form 이벤트

지금까지는 버튼을 누르는 단순한 클릭만 배웠지만, 실제 서비스에서는 사용자의 **글자 입력** 을 받아야 하는 경우가 훨씬 많습니다.

### 📌 _Form_, 이런 곳에 쓰입니다
- Todo 내용 입력
- 검색어 입력
- 로그인 및 회원가입

> **Todo-List 앱의 진정한 시작** 은 버튼이 아니라 **input + form** 입니다.

이번 섹션에서는 본격적인 프로젝트 실습 전에 꼭 필요한 입력 처리의 기초를 다룹니다.`},{id:"form-controlled-input",section:7,order:1,title:"input 값은 왜 State로 관리할까요?",type:0,exp:15,time:8,content:`# 🕹️ 내 마음대로 조종하는 제어 컴포넌트

React에서 input은 단순히 글자가 써지는 상자가 아니라, **State와 연결된 장치** 입니다. 이를 **제어 컴포넌트** 라고 부릅니다.

### ❓ 왜 입력이 안 될까요?
\`\`\`jsx
const [text, setText] = useState('');

<input value={text} /> // value가 빈 값('')으로 고정됨!
\`\`\`
이렇게만 쓰면 키보드를 눌러도 글자가 써지지 않습니다. \`value\` 가 State에 꽉 묶여있기 때문이죠. 

**해결책** : 사용자가 입력할 때마다 State를 바꿔주는 **이벤트** 가 세트로 필요합니다!`},{id:"form-onchange",section:7,order:2,title:"onChange 이벤트로 입력값 처리하기",type:0,exp:20,time:12,content:`# 🔄 실시간 입력 감지: onChange

사용자가 글자를 한 자 한 자 입력할 때마다 실행되는 이벤트가 바로 **onChange** 입니다. \`onChange\` 

 ### ✅ 예시 코드로 보기 

\`\`\`jsx
function InputExample() {
  const [text, setText] = useState('');

  const handleChange = (e) => {
    setText(e.target.value); // 입력한 글자를 State에 저장!
  };

  return <input value={text} onChange={handleChange} />;
}
\`\`\`

**🖥️ 브라우저 흐름**
 키보드 입력 ➡️ onChange 발생 ➡️  setText 실행 ➡️  State 변경 ➡️  화면(input) 업데이트`},{id:"form-event-object",section:7,order:3,title:"이벤트 객체(e)는 무엇인가요?",type:0,exp:15,time:8,content:`# 📦 정보 꾸러미, 이벤트 객체(e)

이벤트 함수를 만들 때 매개변수로 받는 **e** 는 발생한 이벤트의 모든 정보(어디서 클릭됐는지, 어떤 글자가 입력됐는지 등) 가 담긴 객체입니다.

---

### 🏷️ 이름은 자유, 하지만 약속은 필수!

함수의 매개변수 이름을 **e** 로 지을지, **event** 로 지을지는 전적으로 개발자의 자유입니다. 
심지어 **apple** 이나 **data** 라고 지어도 코드는 똑같이 동작합니다.

하지만 전 세계 개발자들은 관용적으로 다음과 같은 이름을 사용합니다
- **e** (가장 많이 사용)
- **ev**
- **event**

**"왜 굳이 저 이름을 쓰나요?"**
코드도 하나의 언어이기 때문입니다. 다른 사람이 내 코드를 봤을 때 "아, 이건 이벤트 객체를 다루는 변수구나!"라고 즉시 이해할 수 있도록 **약속된 키워드** 를 쓰는 것이 개발자들 사이의 중요한 관례입니다.

---

### 🔑 가장 중요한 속성 하나
**\`e.target.value\`**
현재 input 상자에 입력된 **실제 텍스트** 값입니다.



지금 단계에서는 이것 하나만 기억해도 충분합니다! 나머지 복잡한 정보들은 나중에 필요할 때 하나씩 꺼내 쓰면 됩니다.`},{id:"form-submit",section:7,order:4,title:"form과 onSubmit 이벤트",type:0,exp:20,time:10,content:`# 📨 한 번에 제출하기: form & onSubmit

보통 입력창 하나와 버튼 하나를 묶어서 데이터를 처리할 때 **<form>** 태그를 사용합니다.
 \`<form>\`

### ❓ 왜 굳이 form으로 감싸나요?
단순히 \`<div>\` 로 묶어도 되지만, \`<form>\` 을 사용하면 웹 브라우저가 제공하는 **'제출(Submit) 기능'** 을 그대로 활용할 수 있기 때문입니다.

### ✅ 예시 코드로 보기
\`\`\`jsx
<form onSubmit={handleTodoSubmit}>
  <input />
  <button type="submit">추가</button>
</form>
\`\`\`

---

### 🧠 onSubmit은 어떻게 작동하나요?
 **1.자동 감지** 
 >버튼을 클릭하거나, 입력창에서 **Enter키** 를 누르면 브라우저가 "아, 이 양식을 제출하려나 보구나!"라고 판단합니다.
 
 **2.이벤트 발생** 
 >그 순간 **<form>** 태그에 걸려있는 **onSubmit** 함수가 실행됩니다.

### 💡 사용자가 편해지는 장점
- **장점 1** : 일일이 클릭 이벤트를 걸지 않아도 버튼 하나로 제출됩니다.
- **장점 2** : 마우스를 쓰지 않고 **Enter키** 만 쳐도 데이터가 넘어가므로 사용자 경험(UX)이 훨씬 좋아집니다.

> 📌 즉, **form** 은 데이터를 보내기 위한 **하나의 세트** 라고 생각하면 쉽습니다!`},{id:"form-prevent-default",section:7,order:5,title:"event.preventDefault()는 왜 필요할까요?",type:0,exp:20,time:10,content:`# 🛑 새로고침 멈춰! preventDefault

HTML의 **form** 은 제출되는 순간 페이지를 **새로고침** 해버리는 아주 오래된 습성이 있습니다.

### ❌ 새로고침의 문제
리액트 앱에서 새로고침이 일어나면, 정성껏 쌓아둔 **State가 모두 초기화** 되어 버립니다.

### ✅ 해결 방법
\`\`\`jsx
const handleSubmit = (e) => {
  e.preventDefault(); // "브라우저야, 네 맘대로 새로고침하지 마!"
  // 이후에 원하는 로직 작성
};
\`\`\`

리액트 프로젝트의 모든 Form 제출 함수에는 이 코드가 **첫 줄** 에 들어간다고 보셔도 무방합니다.`},{id:"form-submit-example",section:7,order:6,title:"입력 + 제출 전체 흐름 예제",type:0,exp:25,time:15,content:`# 🧩 조각 모음: Form 완성 예제

입력부터 제출, 초기화까지의 전체 과정을 한눈에 확인해봅시다.

\`\`\`jsx
function SimpleForm() {
  const [text, setText] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log("제출된 데이터:", text);
    setText(''); // 제출 후 입력창 비우기
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button type="submit">확인</button>
    </form>
  );
}
\`\`\`

이 코드의 구조가 여러분이 곧 만들게 될 **Todo-List의 핵심 뼈대** 가 됩니다!`},{id:"quiz-form-onchange",section:7,order:7,title:"input 이벤트 퀴즈",type:1,exp:20,time:3,question:"input의 값이 바뀔 때마다 실행되어 State를 업데이트하기 위해 사용하는 React 이벤트는 무엇인가요?",options:["onClick","onSubmit","onChange","onInput"],correctAnswerIndex:2},{id:"quiz-form-prevent",section:7,order:8,title:"Form 이벤트 단답 퀴즈",type:2,exp:25,time:4,question:"form 제출 시 브라우저의 기본 동작(새로고침)을 막기 위해 호출하는 메서드는 무엇인가요?",correctAnswer:"preventDefault,,e.preventDefault,,preventDefault(),,e.preventDefault()"},{id:"form-summary-review",section:7,order:9,title:"Section 7 마무리: Form 이벤트 정리",type:0,exp:15,time:7,content:`# 🏁 섹션 7 마무리

이제 여러분은 사용자의 목소리(입력값)를 들을 준비가 되었습니다!

### ✅ 핵심 요약
- **제어 컴포넌트** : input의 값(**value**) 을 State와 동기화한다.
- **onChange** : 입력할 때마다 State를 실시간으로 바꾼다.
- **preventDefault()** : 폼 제출 시 원치 않는 새로고침을 막아준다.

---

고생하셨습니다! 이제 더 이상 연습용 예제는 그만. 
다음 섹션에서는 지금까지 배운 모든 조각을 하나로 합쳐 **진짜 Todo-List 프로젝트** 를 시작합니다! 💪🚀`},{id:"todo-intro-structure",section:8,order:0,title:"Todo 프로젝트 시작 & 구조 살펴보기",type:0,exp:15,time:7,content:`# 🛠️ 진짜 서비스를 만들어봅시다

이번 섹션에서는 지금까지 배운 모든 퍼즐 조각을 맞춰 **Todo List 앱** 을 처음부터 직접 만들어봅니다.

### 📁 프로젝트 구성 및 파일 구조
우리는 처음부터 파일을 잘게 나누지 않고, **App.jsx** 에서 핵심 기능을 먼저 완성한 뒤 부품(컴포넌트)을 하나씩 분리할 예정입니다.

최종적으로 우리가 갖게 될 파일 구조는 다음과 같습니다.

\`\`\`bash
src/
 ┣ App.jsx (메인 부모 - 모든 상태 관리)
 ┗ components/ (부품 폴더)
    ┣ TodoForm.jsx (입력 영역)
    ┗ TodoList.jsx (목록 표시 영역)
\`\`\`

---

### 🧭 컴포넌트 계층도 미리보기

각 컴포넌트가 어떤 역할을 맡게 되는지 머릿속으로 그려보세요.

\`\`\`text
App (상태 관리의 중심)
┃
┣━ TodoForm (입력 창)
┃  ┗━ [input] + [추가 버튼]
┃
┗━ TodoList (할 일 목록)
    ┗━ [삭제 버튼]을 포함한 리스트 아이템들
\`\`\`

---

💡 **학습 팁**
> 처음부터 여러 파일을 왔다 갔다 하면 흐름을 놓치기 쉽습니다.
> 강의의 흐름에 따라 **한 파일에서 기능을 완성하고, 이를 컴포넌트로 추출(Extracting)하는 과정** 을 경험해 보세요.
> 스타일(CSS)보다는 **데이터가 어떻게 흐르는지(State & Props)** 에만 집중합시다!`},{id:"todo-state-init",section:8,order:1,title:"Todo 리스트 상태 만들기",type:0,exp:20,time:8,content:`# 뼈대 만들기: 데이터 구조 잡기

가장 먼저 할 일 목록을 저장할 **State** 를 만들어야 합니다.

### 🧠 Todo 데이터의 생김새
각각의 할 일은 구분을 위해 **ID** 와 **내용** 이 필요합니다.

\`\`\`jsx
const [todos, setTodos] = useState([
  { id: 1, text: '리액트 기초 정복하기' },
  { id: 2, text: '투두 앱 완성하기' },
]);
\`\`\`

---
### 📌 기억하세요
 목록은 **배열 \`[ ]\`** 형태입니다.
 목록 안의 하나하나의 데이터는 **객체 \`{ }\`** 형태입니다.`},{id:"todo-render-list",section:8,order:2,title:"Todo 리스트 화면에 출력하기",type:0,exp:20,time:10,content:`# 🖼️ 화면에 뿌려주기: map()

만들어둔 데이터를 사용자에게 보여줄 차례입니다.

\`\`\`jsx
<ul>
  {todos.map((todo) => (
    <li key={todo.id}>{todo.text}</li>
  ))}
</ul>
\`\`\`

---
### 📌 체크 포인트
- **map()** 을 써서 배열 개수만큼 **<li>** 를 만듭니다.
- 리액트가 헷갈리지 않게 고유한 키 값을 꼭 넣어주세요! \`key={todo.id}\``},{id:"todo-input-state",section:8,order:3,title:"입력 폼과 입력 상태 만들기",type:0,exp:20,time:10,content:`# ✍️ 글자 입력받기

새로운 할 일을 입력할 상자와 그 값을 기억할 State를 만듭니다.

\`\`\`jsx
const [input, setInput] = useState('');

// ...중략

<input
  value={input}
  onChange={(e) => setInput(e.target.value)}
  placeholder="할 일을 입력하세요"
/>
\`\`\`

### 📌 왜 이렇게 하나요?
> 입력창의 값(**value**) 을 State(**input**) 와 연결해야 리액트가 입력값을 완벽하게 제어할 수 있습니다. (이걸 **제어 컴포넌트** 라고 불렀었죠!)`},{id:"todo-submit-add",section:8,order:4,title:"폼 제출로 Todo 추가하기",type:0,exp:25,time:15,content:`# ➕ 리스트에 새 항목 추가하기

이제 입력한 글자를 진짜 리스트에 넣어봅시다.

\`\`\`jsx
const onSubmit = (e) => {
  e.preventDefault(); // 새로고침 방지!

  const newTodo = {
    id: Date.now(), // 고유한 ID 생성
    text: input,
  };

  setTodos([...todos, newTodo]); // 불변성 유지하며 추가!
  setInput(''); // 입력창 비워주기
};
\`\`\`

### 💡 여기서 잠깐! Date.now()가 뭐죠?
ID는 리스트에서 각 항목을 구분하는 **주민등록번호** 와 같습니다. 그래서 절대 중복되면 안 되죠.

- **Date** : 자바스크립트에서 날짜와 시간을 다루는 도구입니다.
- **.now()** : 이 함수를 실행하는 **'그 찰나의 시간'** 을 밀리초(1/1000초) 단위의 숫자로 반환합니다.
- **왜 쓰나요?** : 시간은 멈추지 않고 흐르기 때문에, 실행할 때마다 항상 다른 숫자가 나옵니다. 덕분에 별도의 데이터베이스가 없는 연습용 프로젝트에서 **중복되지 않는 고유 ID** 를 만들 때 아주 유용하게 쓰입니다!

---

### ✅ 이제 가능한 기능
- 글자 입력 후 Enter 또는 버튼 클릭 ➡️ 입력한 값이 목록에 짠! 하고 나타납니다.
- 리액트의 **불변성 원칙** 덕분에 화면이 즉시 업데이트됩니다.`},{id:"todo-split-components",section:8,order:5,title:"심화 1: 컴포넌트로 분리해보기",type:0,exp:20,time:15,content:`# ✂️ 코드 청소: 단계별로 부품 나누기

지금까지 **App.jsx** 라는 큰 방에 모든 가구를 다 집어넣었습니다. 이제 역할에 따라 방(컴포넌트) 을 나누어 이사를 해봅시다.

---

### 🏗️ STEP 1: 새로운 폴더와 파일 만들기
먼저 부품들을 담을 전용 폴더와 파일을 생성합니다.
1️⃣ src 폴더 안에 **components** 라는 새 폴더를 만듭니다.
2️⃣ components 폴더 안에 **TodoForm.jsx** 와 **TodoList.jsx** 파일을 만듭니다.

![components-sample](${m})

---

### 🏗️ STEP 2: 코드 잘라내어 옮기기
**App.jsx** 에 있던 UI 코드를 각각의 파일로 복사해 넣습니다. 이때 각 파일은 독립된 함수 형태를 갖춰야 합니다.

**1️⃣ TodoForm.jsx**
\`\`\`jsx
function TodoForm() {
  return (
    <form onSubmit={onSubmit}>
      <input 
        value={input} 
        onChange={onInputChange} 
        placeholder="할 일을 입력하세요" 
      />
      <button>추가</button>
    </form>
  );
}
export default TodoForm;
\`\`\`

**2️⃣ TodoList.jsx**
\`\`\`jsx
function TodoList() {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
export default TodoList;
\`\`\`

---

### 🏗️ STEP 3: App.jsx에서 부품 불러오기
방금 만든 부품들을 **App.jsx** 에서 사용할 수 있도록 불러옵니다(Import).

**현재 App.jsx 의 모습**
\`\`\`jsx
import { useState } from 'react';
// 1. 방금 만든 부품들을 불러옵니다.
import TodoForm from './components/TodoForm'; 
import TodoList from './components/TodoList'; 

function App() {
  const [todos, setTodos] = useState([
    { id: 1, text: '리액트 기초 정복하기' },
    { id: 2, text: '투두 앱 완성하기' },
  ]);
  const [input, setInput] = useState('');

  const onSubmit = (e) => {
    e.preventDefault();
    const newTodo = { id: Date.now(), text: input };
    setTodos([...todos, newTodo]);
    setInput('');
  };

  return (
    <div>
      <h1>My Todo List</h1>
      {/* 2. 잘라낸 자리에 부품을 배치합니다. */}
      <TodoForm /> 
      <TodoList />
    </div>
  );
}

export default App;
\`\`\`

### 💡 위 단계에 맞춰 파일을 분리하고 저장해 보세요.
>  아마 화면이 **하얗게 변하며 아무것도 나오지 않을 것** 입니다. 당황하지 마세요! 개발자 도구(F12) 의 콘솔창을 열어보면 **"onSubmit is not defined"** 같은 에러 메시지가 여러분을 기다리고 있을 거예요.

분명히 코드는 그대로 옮겼는데 왜 화면이 사라졌을까요? 다음 강의에서 그 이유와 해결책(Props) 을 함께 알아봅시다.`},{id:"todo-error-why",section:8,order:6,title:"심화 2: 왜 에러가 발생할까요?",type:0,exp:25,time:12,content:`# 🧐 "onSubmit is not defined?"

코드를 완벽하게 복사해서 옮겼는데, 왜 브라우저 콘솔에는 **ReferenceError** (참조 오류) 가 뜰까요?

![reference-error](${x})

### 🧠 원인: 컴포넌트라는 독립된 방

자바스크립트의 모든 변수와 함수는 **선언된 영역(Scope)** 안에서만 살아있습니다. 쉽게 말해, 각 컴포넌트 파일은 서로 벽이 쳐진 **'독립된 방'** 과 같아요.

아래 코드를 보세요. React 입장에선 얼마나 당황스러울까요? 

\`\`\`jsx
// 🏠 TodoForm.jsx 방
function TodoForm() {
  return (
    // ❓ "onSubmit이 누구죠? 이 방엔 그런 사람이 없는데요?"
    <form onSubmit={onSubmit}> 
    {/* ❓ "input은 또 어디서 온 데이터인가요? 금시초문이에요!" */}
      <input value={input} />
      <button>추가</button>
    </form>
  );
}

// 🏠 TodoList.jsx 방
function TodoList() {
  return (
    <ul>
      {/* ❓ "todos는 또 누구인가요? 들어본 적 없는 이름이에요!" */}
      {todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
\`\`\`

- **App.jsx** : **todos**, **onSubmit** 이라는 가구가 배치된 큰 방입니다.
- **자식 컴포넌트들** : 몸만 이사를 간 새 방입니다. 예전 방에 있던 가구들을 하나도 챙겨오지 않았죠.

분명히 부모인 **App** 의 방 안에는 가구들이 있지만, 자식 방에서는 벽에 가로막혀 옆방에 뭐가 있는지 전혀 보이지 않는 상태인 거예요!

---

### 📦 해결책: 데이터 배달 서비스 (Props)

코드를 복사해서 붙여넣는 것만으로는 부족합니다. 부모가 가진 가구(데이터/함수) 를 자식 방으로 공식적으로 보내주는 과정이 필요합니다.

> **Props** 는 부모가 자식에게 보내는 **'택배 상자'** 와 같습니다. 

다음 강의에서 이 상자에 **onSubmit** 과 **todos** 를 담아 자식들에게 안전하게 배달해 보겠습니다! 이제 문을 열고 데이터를 주고받을 시간이에요!`},{id:"todo-pass-props",section:8,order:7,title:"심화 3: 데이터 배달하고 받기 (Props)",type:0,exp:25,time:20,content:`# 🎁 데이터 배달하고 받기: Props로 연결 완료

부모(**App.jsx**) 가 던져준 보따리를 자식들이 받아야 비로소 에러가 해결됩니다. 배달(보내기) 과 수령(받기) 과정을 나누어 살펴봅시다.

---

### 1️⃣ [배달] 부모가 데이터 보내기 (App.jsx)
부모 컴포넌트에서 자식 컴포넌트의 이름을 부를 때, 필요한 가구(데이터/함수) 를 속성으로 적어줍니다.

\`\`\`jsx
// App.jsx 내부
<TodoForm input={input} setInput={setInput} onSubmit={onSubmit} />
<TodoList todos={todos} />
\`\`\`

---

### 2️⃣ [수령] 자식이 데이터 받기 (TodoForm, TodoList)
자식은 함수의 **매개변수** 자리에 **중괄호{ }** 를 열어 부모가 보낸 택배를 꺼내 써야 합니다.



#### 📂 TodoForm.jsx (입력 담당)
\`\`\`jsx
// 📦 매개변수 위치에서 부모가 보낸 이름 그대로 받아줍니다!
function TodoForm({ input, setInput, onSubmit }) {
  return (
    <form onSubmit={onSubmit}>
      <input 
        value={input} 
        onChange={(e) => setInput(e.target.value)} 
      />
      <button type="submit">추가</button>
    </form>
  );
}
export default TodoForm;
\`\`\`

#### 📂 TodoList.jsx (출력 담당)
\`\`\`jsx
// 📦 부모가 준 'todos'를 받아와서 map을 돌립니다.
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
export default TodoList;
\`\`\`

---

### 🏠 3️⃣ 전체 연결 구조 (App.jsx)
이제 부모 컴포넌트에서 모든 배달 준비가 끝났습니다.

\`\`\`jsx
import { useState } from 'react';
import TodoForm from './components/TodoForm';
import TodoList from './components/TodoList';

function App() {
  const [todos, setTodos] = useState([
    { id: 1, text: '리액트 기초 정복하기' },
    { id: 2, text: '투두 앱 완성하기' },
  ]);
  const [input, setInput] = useState('');

  const onSubmit = (e) => {
    e.preventDefault();
    const newTodo = { id: Date.now(), text: input };
    setTodos([...todos, newTodo]);
    setInput('');
  };

  return (
    <div>
      <h1>My Todo List</h1>
      {/* 🚚 데이터 배달 시작! */}
      <TodoForm input={input} setInput={setInput} onSubmit={onSubmit} />
      <TodoList todos={todos} />
    </div>
  );
}
\`\`\`

> 🔑 **꼭 기억하세요!**
> - 부모는 컴포넌트 태그 안에 **이름={값}** 으로 보낸다!
> - 자식은 함수 괄호 안에 **{ 이름 }** 으로 받는다!

이제 하얀 화면이 사라지고 다시 우리 앱이 정상적으로 작동할 거예요! 🎉`},{id:"todo-delete-filter",section:8,order:8,title:"심화 4: Todo 삭제 기능 구현",type:0,exp:30,time:20,content:`# 🗑️ 잘못 만든 일정, 깔끔하게 지우기

추가만큼이나 중요한 기능이 바로 **삭제** 입니다. 이번 시간에는 내가 클릭한 항목만 쏙 골라 지우는 방법을 배워보겠습니다.

---

### 1️⃣ [선언] 삭제 함수 만들기 (App.jsx)

데이터(State) 를 바꾸는 권한은 데이터를 가지고 있는 **부모(App.jsx)** 에게 있습니다. 먼저 부모 방에서 삭제 로직을 작성합니다.

\`\`\`jsx
// App.jsx 내부
const onDelete = (id) => {
  // filter: "내가 클릭한 id와 다른 녀석들만 남겨서 새 목록을 만들어줘!"
  const updatedTodos = todos.filter((todo) => todo.id !== id);
  setTodos(updatedTodos);
};

return (
  <div>
    {/* 🚚 생성한 함수를 TodoList에게 택배(Props)로 보냅니다! */}
    <TodoList todos={todos} onDelete={onDelete} />
  </div>
);
\`\`\`

---

### 2️⃣ [수령 및 사용] 삭제 버튼 달기 (TodoList.jsx)

부모에게 받은 **onDelete** 택배를 풀어서 버튼에 연결해 봅시다.

\`\`\`jsx
// 📦 매개변수 위치에서 onDelete를 수령합니다.
function TodoList({ todos, onDelete }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          {todo.text}
          {/* 🔘 버튼 클릭 시 해당 todo의 id를 배달원(onDelete)에게 보냅니다. */}
          <button onClick={() => onDelete(todo.id)}>삭제</button>
        </li>
      ))}
    </ul>
  );
}
\`\`\`

---

### 🧠 핵심 로직: filter 함수 이해하기

삭제의 핵심은 **"내가 클릭한 녀석만 빼고 나머지는 다 남겨줘!"** 라고 리액트에게 말하는 것입니다.

- **정수기 필터** 를 상상해보세요. 오염물질만 걸러내고 깨끗한 물만 통과시키죠? 
- **조건문 (todo.id !== id)** 이 **참(True)** 인 데이터들만 살아남아 새로운 배열에 담깁니다. 내가 삭제 버튼을 누른 데이터는 이 조건에서 **거짓(False)** 이 되어 탈락하게 되죠.
- **불변성** : 기존 배열을 직접 수정하는 게 아니라, 조건을 통과한 데이터들로 **'완전 새로운 배열'** 을 만들어 갈아끼우는 방식입니다. 그래서 리액트가 변화를 즉시 감지합니다.

---

### 🔑 요약: 데이터의 흐름
1. **App.jsx** : 삭제 로직(**filter**) 을 만들고 자식에게 보낸다.
2. **TodoList.jsx** : 버튼을 누르면 부모에게 받은 함수를 실행하며 클릭된 **id** 를 전달한다.

> 이제 추가와 삭제가 모두 가능한 **진짜 웹 서비스** 의 기본을 갖추게 되었습니다! 👏`},{id:"todo-final-code",section:8,order:9,title:"심화 5: 드디어 완성! 전체 코드 보기",type:0,exp:10,time:5,content:`# 🏁 축하합니다! 투두 앱이 완성되었습니다.

부품별로 나누고, 데이터를 배달하고, 삭제 기능까지! 우리가 함께 만든 투두 앱의 전체 구조를 한눈에 확인해 보세요.

---

### 📂 프로젝트 구조 (File Structure)
현재 여러분의 \`src\` 폴더는 이런 모습이어야 합니다.



---

### 📝 파일별 전체 코드

#### 1️⃣ App.jsx (메인 관제소)
\`\`\`jsx
import { useState } from 'react';
import TodoForm from './components/TodoForm';
import TodoList from './components/TodoList';

function App() {
  const [todos, setTodos] = useState([
    { id: 1, text: '리액트 기초 정복하기' },
    { id: 2, text: '투두 앱 완성하기' },
  ]);
  const [input, setInput] = useState('');

  // 추가 로직
  const onSubmit = (e) => {
    e.preventDefault();
    if (!input.trim()) return; // 빈 값 방지
    const newTodo = { id: Date.now(), text: input };
    setTodos([...todos, newTodo]);
    setInput('');
  };

  // 삭제 로직
  const onDelete = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <div className="app-container">
      <h1>My Todo List</h1>
      <TodoForm 
        input={input} 
        setInput={setInput} 
        onSubmit={onSubmit} 
      />
      <TodoList 
        todos={todos} 
        onDelete={onDelete} 
      />
    </div>
  );
}

export default App;
\`\`\`

#### 2️⃣ components/TodoForm.jsx (입력 부품)
\`\`\`jsx
function TodoForm({ input, setInput, onSubmit }) {
  return (
    <form onSubmit={onSubmit}>
      <input 
        value={input} 
        onChange={(e) => setInput(e.target.value)} 
        placeholder="할 일을 입력하세요"
      />
      <button type="submit">추가</button>
    </form>
  );
}

export default TodoForm;
\`\`\`

#### 3️⃣ components/TodoList.jsx (목록 부품)
\`\`\`jsx
function TodoList({ todos, onDelete }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          {todo.text}
          <button onClick={() => onDelete(todo.id)}>삭제</button>
        </li>
      ))}
    </ul>
  );
}

export default TodoList;
\`\`\`

---

> **💡 마지막 체크리스트**
> ✔ 추가 버튼을 눌렀을 때 목록이 잘 늘어나나요?
> ✔ 삭제 버튼을 눌렀을 때 해당 항목만 쏙 사라지나요?
> ✔ 입력창에 글자를 칠 때 에러 없이 잘 써지나요?

모든 게 완벽하다면, 여러분은 이제 **리액트의 핵심(컴포넌트, 상태, Props)** 을 마스터한 것입니다! 🎉`},{id:"todo-section8-summary",section:8,order:10,title:"Section 8 마무리: Todo 앱 완성",type:0,exp:20,time:7,content:`# 🎉 리액트로 만든 첫 번째 서비스, 완성을 축하합니다!

여러분은 방금 실제 동작하는 서비스를 리액트로 직접 구현해냈습니다. 머릿속으로만 그리던 기능들을 **'내 코드'** 로 증명해낸 아주 값진 순간입니다.

---

### 🧠 이번 섹션의 핵심 포인트 (Review)
방금 완성한 전체 코드 속에는 리액트의 정수가 모두 담겨 있습니다.
- **상태 관리** : **useState** 로 사용자의 입력과 리스트 데이터를 실시간으로 제어했습니다.
- **데이터 배달** : 부품(컴포넌트) 을 나누고, **Props** 라는 택배로 데이터와 함수를 주고받았습니다.
- **안전한 삭제** : 원본을 건드리지 않는 **불변성** 의 원칙을 지키며 **filter** 로 데이터를 삭제했습니다.

---

### 🚀 다음 레벨로 가기 위한 도전 과제
기본 뼈대는 완성되었습니다! 이제 이 앱에 여러분만의 색깔을 입혀볼 차례입니다.

- **🎨 스타일링** : CSS를 활용해 투두 앱에 멋진 옷을 입혀보세요.
- **🛠️ 기능 확장** : "전체 삭제" 버튼을 만들거나, 할 일을 "수정" 하는 기능에 도전해 보세요.
- **✅ 완료 체크** : 할 일을 클릭하면 가로줄이 그어지는 '완료 상태' 를 추가해 보는 건 어떨까요?

---

### 🤝 여러분의 결과물을 자랑해 주세요!
여러분의 개성이 담긴 Todo List가 정말 궁금합니다. 완성된 화면이나 코드를 **커뮤니티 페이지** 에 공유해 보세요! 동료들과 코드를 나누며 피드백을 주고받는 과정은 가장 빠르게 성장하는 지름길입니다.

정말 고생 많으셨습니다! 이 투두 앱이 여러분의 리액트 여정에 든든한 첫 번째 이정표가 되길 진심으로 응원합니다. 👏

\`\`\`jsx
// 여러분의 열정을 응원하며!
return (
  <Congratulations message="See you in the next level!" />
); 
// Made by Ryan
\`\`\``}],T=[{id:"section1-orientation",section:1,order:0,title:"講義を始める：何を作るのでしょうか？",type:0,exp:5,time:5,content:`# 🚀 ようこそ！ Reactの世界へ

こんにちは 👋 

 皆さんはこの講義を通じて、React.jsに関する基礎知識を身につけることができます。

 本講義は **Reactに初めて触れる方も** 実際に一つの完成されたウェブアプリケーションを作ってみることを目標としています。

---

### 🧠 受講前に知っておくと良いこと

Reactを学ぶ前に、以下のような **基本的なウェブ開発の知識** を知っておくと、よりスムーズに進めることができます。

📌 **必要な事前知識** 
> - 基本的な **HTML構造** (タグ、属性など)
> - **JavaScriptの基礎文法** (変数、関数、配列)

---

### 🎯 講義コンセプト

- Reactの核心概念を **直接作りながら** 理解します。
- 複雑な理論より、**「なぜこのように使うのか」** という実用性に集中します。

---

### 🧩 最終目標のプレビュー

私たちは今回の講義を通じて、**Todo-Listアプリケーション** をゼロから直接完成させてみます。

![Todo Sample](${v})

さあ、それでは始めてみましょう！`},{id:"intro-what-is-react",section:1,order:1,title:"React.jsとは何か？",type:0,exp:10,time:7,content:`# ⚛️ React: UIを作るための強力なツール

**React** はユーザーインターフェース(UI)を作るための **JavaScriptライブラリ** です。Meta(旧Facebook)によって開発され、現在最も愛されているフロントエンド技術です。

---

### 💡 なぜReactなのですか？

ウェブページでボタンをクリックした時、画面全体がリロードされずに **必要な部分だけ** がスムーズに更新される体験をしたことがありますか？ Reactは、このような動的な画面を **効率的に実装** するために誕生しました。

---

### 📦 ライブラリ vs フレームワーク

多くの人が迷うこの2つの概念の核心は、 **「誰が主導権を持っているか」** です。

- **ライブラリ** : 開発者が中要な時に **直接選んで使う道具箱** です。自分が欲しい時に必要な機能だけを取り出して使えます。
- **フレームワーク** : 家を建てる時に使う **あらかじめ決められた枠組み** です。決められたルールと流れに必ず従わなければならず、その中でコードを書く必要があります。

**「だから、Reactはライブラリなのです！」**
Reactはウェブ全体を管理するルールを強制しません。ただ **「UIを作るツール」** としての役割に集中しています。
したがって、開発者が好む他のツールと **自由に組み合わせて** 使用できることが、最大の魅力です。`},{id:"intro-spa-concept",section:1,order:2,title:"ページ全体が変わらない理由 (SPA)",type:0,exp:10,time:5,content:`# 🪄 ページが変わらない魔法、SPA

Reactは **SPA(Single Page Application)** 方式で動作します。画面全体が「点滅」することなく内容がスムーズに変わる秘密が、まさにここにあります。

---

### 📌 SPAとは何でしょうか？

伝統的なウェブサイトは、他のページに移動するたびにサーバーから画面全体を再度読み込みます。しかしSPAは
- たった **一つのページ(HTML)** だけをロードします。
- その後はJavaScriptを利用して **必要なデータだけ** を入れ替えます。

> **💡 SPAのメリット** 
> 1. 画面の点滅がなく、**アプリのような滑らかな体験** を提供します。
> 2. サーバーとの通信量が減り、**速度が非常に速くなります。** `},{id:"quiz-react-definition",section:1,order:3,title:"Reactの定義クイズ",type:2,question:"ReactはJavaScriptのどのような種類のツールですか？ (5文字)",correctAnswer:"ライブラリ,,ライブラリー,,Library",explanation:"ReactはUI構築のための専用機能を提供する「ライブラリ」です。",exp:20,time:3},{id:"intro-why-react",section:1,order:4,title:"なぜReactを学ぶ必要があるのでしょうか？",type:0,exp:10,time:6,content:`# 🌟 Reactを学ぶべき3つの理由

世界中の多くの開発チームがReactを選択するのには、明確な理由があります。

1. **コンポーネントの再利用** 
一度しっかり作ったUIを、あちこちで繰り返し使うことができます。

2. **圧倒的なエコシステム** 
わからないことがあった時に調べる資料や、一緒に使えるツールが世界で最も多いです。

3. **宣言的プログラミング** 
画面の状態が「どのように」変わるかをいちいち命令せず、「何」を見せるかだけ決めれば、Reactが自動的に描画してくれます。

> Reactを学ぶことは単に文法を覚えることではなく、**現代的な開発者の思考回路** を身につける過程です。`},{id:"app-creation-vite",section:1,order:5,title:"アプリの作成 - Vite",type:0,exp:15,time:15,content:`# 🛠️ 実戦！最初のReactアプリ作成

実際にReactプロジェクトを作成してみましょう。ここでは最も高速でモダンなツールである **Vite** を使用します。

---

### ⌨️ ターミナルコマンドを順番に入力してください

1️⃣ **プロジェクトの生成** 
\`\`\`bash
npm create vite@latest my-todo-app -- --template react
\`\`\`

2️⃣ **プロジェクトフォルダへの移動とツールのインストール** 
\`\`\`bash
cd my-todo-app
npm install
\`\`\`

3️⃣ **開発サーバーの実行** 
\`\`\`bash
npm run dev
\`\`\`

サーバーが実行されたら、ターミナルに表示されたアドレスをブラウザに入力してみてください。あなたの最初のReact画面が表示されます！ \`http://localhost:5173\`

---

### 🧹 プロジェクトの初期設定（クリーニング）

Viteがデフォルトで提供するサンプルコードは、私たちのプロジェクトには必要ありません。きれいに整理しましょう。

4️⃣ **不要なコードおよびファイルの削除** 
- **index.css** : ファイル内のすべてのコードを選択して削除（空に）してください。
- **App.css** : このファイルは使用しないため、 **ファイル自体を削除** します。
- **App.jsx** : 以下のコードだけを残して、すべて削除してください。
\`\`\`jsx
function App() {
  return (
    <div>
      <h1>Hello, React!</h1>
    </div>
  );
}

export default App;
\`\`\`

![Code Clean](${u})

5️⃣ **整理された初期画面の確認** 
上記の作業をすべて終えると、ブラウザにはスタイルが適用されていない白い背景に **Hello, React!** という文字だけが表示されます。これで本格的な開発の準備が完了しました！

![Hello React](${l})
`},{id:"section1-summary",section:1,order:6,title:"セクション 1 まとめ：Reactの全体像",type:0,exp:5,time:4,content:`# 🏁 セクション 1 まとめ

このセクションでは、Reactを始める前に必ず知っておくべき **全体像** を見てきました。

---

### ✅ このセクションで学んだこと

- ReactはUIを作る **ライブラリ** である。
- **SPA** 方式を通じて滑らかなユーザー体験を提供する。
- **Vite** を利用して速く現代的な開発環境を構築した。

---

これで準備運動は終わりです。

次のセクションからは、Reactの核心である **コンポーネントとJSX** を直接触りながら、コードを書いていきましょう！ 🚀`},{id:"basic-understanding-components",section:2,order:0,title:"コンポーネント(Components)を理解する",type:0,exp:10,time:6,content:`# 🧱 UIの欠片、コンポーネント(Component)

**コンポーネント** はUIを構成する **独立しており再利用可能なブロック** です。まるでレゴブロックを組み立てるようにウェブサイトを作ることができます。

---

### 💻 Reactコンポーネントは実は関数です

最も基本的な形態のコンポーネントは **JavaScript関数** です。

\`\`\`jsx
function Welcome() {
  return <h1>こんにちは、React！</h1>;
}
\`\`\`

このように作ったコンポーネントは、まるでHTMLタグのように使用できます。

\`\`\`jsx
<Welcome />
\`\`\`

---

### 🧠 コンポーネントを関数として理解しましょう

> 📌 **入力値を受け取って → 画面(UI)を返す関数** 
- 入力値: props (データ)
- 返り値: 画面に表示されるJSX

つまり、Reactでは **関数で画面を作る** と考えても差し支えありません。

> ⚠️ **注意**
> コンポーネント名の最初の文字は必ず **大文字** でなければなりません。
> 小文字で始めると、Reactはこれを通常のHTMLタグとして認識してしまいます。`},{id:"basic-jsx-syntax",section:2,order:1,title:"JSX：JavaScriptの中のHTML",type:0,exp:10,time:10,content:`# 🏗️ JavaScript拡張構文、JSX

**JSX** は **JavaScriptの中でHTMLのように見える構文** を使用できるようにするReactの核心的な構文です。

---

### ❓ なぜJSXが必要なのでしょうか？

JSXがなければ、私たちは一つずつ複雑なJavaScript関数を呼び出さなければなりません。

\`\`\`js
// JSXなしで記述する場合
React.createElement('h1', null, 'こんにちは');
\`\`\`

---

### 🔀 JavaScriptの値を混ぜて使う 

 JSXの強力な点は、JavaScriptの変数を **中括弧** \`{ }\` を通じて画面にすぐ表示できる点です。

\`\`\`jsx
function App() {
  const name = '太郎';
  const age = 20;

  return <h2>{name}さんは{age}歳です。</h2>;
}
\`\`\`

**🖥️ ブラウザ出力結果:** 
> **太郎さんは20歳です。** 
 
このように中括弧の中のJavaScript変数が実際のデータに置換されて画面に現れます。`},{id:"basic-jsx-rules",section:2,order:2,title:"JSX記述時に必ず守るべき規則",type:0,exp:15,time:8,content:`# 📏 JSXを使用する際に守るべき3つの約束

JSXはHTMLと似た形をしていますが、実際にはJavaScriptであるため、いくつかの厳格な規則があります。

### 1️⃣ 必ず一つのタグで囲むこと
二つ以上のタグを並べる時は、必ず親タグで囲まなければなりません。名前のないタグである\`<> ... </>\` **Fragment** を使用すれば、不要なdivを減らすことができます。

\`\`\`jsx
return (
  <>
    <h1>タイトル</h1>
    <p>内容</p>
  </>
);
\`\`\`

### 2️⃣ classではなくclassName
JavaScriptにおいて \`class\` という単語はすでに予約語として使われています。したがってCSSクラスを指定する時は **className** を使用します。

\`\`\`jsx
<div className="header">メニュー</div>
\`\`\`

### 3️⃣ すべてのタグは閉じなければなりません

 \`\`\`jsx
<img> 
 <input>
\`\`\` 

 上記の二つのタグのようにHTMLで閉じなかったタグも、JSXでは必ず \`<img />\` のように **Self-closing** するか、閉じなければなりません。`},{id:"quiz-jsx-definition",section:2,order:3,title:"JSXの概念クイズ",type:1,exp:20,time:3,question:"次のうち、JSXに関する説明として最も適切なものはどれですか？",options:["HTMLファイルを代替するための新しい言語","ブラウザで直接実行されるテンプレート言語","JavaScriptの中でHTMLのように見える構文を使用できるようにする構文","React専用のスタイリング構文"],correctAnswerIndex:2,explanation:"JSXはJavaScript XMLの略語で、コードの可読性を高めてくれるJavaScript拡張構文です。"},{id:"quiz-jsx-expression",section:2,order:4,title:"JSX式クイズ",type:1,exp:20,time:3,question:"JSXの中でJavaScript変り数を出力する時に使用する正しい方法は何ですか？",options:["<p>name</p>","<p>${name}</p>","<p>{name}</p>","<p>(name)</p>"],correctAnswerIndex:2,explanation:"JSX内部でJavaScript変数や式を使用する時は、必ず中括弧 { } を使用しなければなりません。"},{id:"quiz-jsx-statement-vs-expression",section:2,order:5,title:"JSX構文理解クイズ",type:1,exp:25,time:4,question:"次のうち、JSXの中で直接使用できないものはどれですか？",options:["三項演算子 (condition ? A : B)","数値計算 (1 + 2)","if 文","変数の値の出力"],correctAnswerIndex:2,explanation:"JSX内の中括弧には、結果値が即座に返される「式(expression)」だけが来ることができます。if文は「文(statement)」であるため、中括弧内部で直接使用することはできません。"},{id:"section2-summary",section:2,order:6,title:"セクション 2 まとめ：コンポーネントとJSX",type:0,exp:5,time:4,content:`# 🏁 セクション 2 締めくくり

お疲れ様でした！ これで皆さんはReactアプリの基礎となる骨組みを作る方法を学びました。

---

### ✅ 核心まとめ
- **コンポーネント** はUIの最小単位であり、名前は **大文字** から始める。
- **JSX** はJavaScriptとHTMLの出会いである。
- JSXは必ず **一つの親** タグで囲まなければならず、 **className** を使用する。

---

骨組みを作ったので、次はここに **「生命力（データの変化）」を** 吹き込む番です。
次のセクションの **State** で会いましょう！ 🚀`},{id:"state-what-is-state",section:3,order:0,title:"Stateとは何か？",type:0,exp:15,time:8,content:`# 🧠 コンポーネントの記憶装置、State

Reactにおいて **State** は、コンポーネントが内部的に **記憶している値** です。
ユーザーとの相互作用によっていつでも **変更される可能性のあるデータ** を意味します。

---

### ❓ なぜ通常の変数では画面が変わらないのでしょうか？

\`\`\`jsx
let count = 0;

function Counter() {
  const increase = () => {
    count = count + 1;
    console.log(count); // 値は上がりますが、画面はそのままでした！
  };

  return (
    <div>
      <p>{count}</p>
      <button onClick={increase}>増加</button>
    </div>
  );
}
\`\`\`

通常の変数は値が変わっても、 **Reactが画面を描画し直さなければならないことを認識できません。** つまり、コンポーネントを **レンダリング** しないためです。

---

### ✅ だからStateが必要です

Stateは単なるデータではなく、 **「値が変わったから画面を描画し直して（レンダリングして）！」** とReactに送る信号です。

> 📌 **ここで言う「レンダリング(Rendering)」とは？**
> コンポーネント関数が再び呼び出され、その結果として変更されたデータが反映された **新しい画面(UI)がブラウザに描画される過程** を指します。

Stateが変更されると、Reactは自動的にこのレンダリング過程を実行し、ユーザーが変更された値を確認できるようにします。`},{id:"state-counter-practice",section:3,order:1,title:"カウンターアプリ実習：useStateの使い方",type:0,exp:25,time:10,content:`# 🛠️ useStateで数値を変える

では、実際に画面を更新するコードを書いてみましょう。Reactが提供する \`useState\` というツールを使用します。

\`\`\`jsx
import { useState } from 'react'; // 👈 必ずインポートする必要があります！

function Counter() {
  // [現在値, 更新関数] = useState(初期値);
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>現在の数字: {count}</p>
      <button onClick={() => setCount(count + 1)}>増加</button>
    </div>
  );
}
\`\`\`

**🖥️ ブラウザ出力結果:** 
> 現在の数字: 0  
> [増加ボタン]

**🔄 ボタンを押すと起こること:** 
1. \`setCount\` 関数が実行され、 \`count\` が変更されます。
2. Reactが「おや？ countが変わったな」と検知します。
3. **コンポーネントを再実行（再レンダリング）** して、画面に新しい数値を描画します。`},{id:"quiz-state-description",section:3,order:2,title:"State概念理解クイズ",type:2,question:"コンポーネントが記憶しており、値が変更されると画面が再レンダリングされるようにするReactのデータは何ですか？",correctAnswer:"State,,state,,ステート,,状態,,状態値",explanation:"Stateはコンポーネント内部で変化する値を管理し、変更時にレンダリングを誘発します。",exp:20,time:3},{id:"quiz-state-update-code",section:3,order:3,title:"State変更コードクイズ",type:2,question:`次の状態が宣言されているとき、numberの値を5に変更する関数呼び出しコードを記述してください。

const [number, setNumber] = useState(0);`,correctAnswer:"setNumber(5)",explanation:"状態変更関数であるsetNumberに、希望する値を引数として渡します。",exp:30,time:4},{id:"quiz-state-change-effect",section:3,order:4,title:"State変更結果クイズ",type:1,question:"Stateの値が変更されると、Reactコンポーネントにはどのようなことが起こりますか？",options:["何も起こらない","ページ全体がリロードされる","該当するコンポーネントが再レンダリングされる","エラーが発生する"],correctAnswerIndex:2,explanation:"ReactはStateの変化を検知して、該当するコンポーネントを再レンダリングします。",exp:20,time:3},{id:"state-common-mistakes",section:3,order:5,title:"+ Stateで最もよくある間違い",type:0,exp:20,time:15,content:`# ⚠️ 初心者が最も陥りやすいStateの間違い

### 1️⃣ Stateを直接修正しないでください
\`\`\`jsx
// ❌ 絶対にダメです！
count = count + 1;

// ✅ 常にこのようにしてください
setCount(count + 1);
\`\`\`
直接修正すると、Reactは値が変わったことに気づかず、画面をそのままにしてしまいます。

### 2️⃣ Stateは「次のレンダリング」で変わります
\`\`\`jsx
setCount(count + 1);
console.log(count); // 🧐 まだ以前の値が表示されます！
\`\`\`
\`setCount\` を実行してすぐに値が変わるのではなく、 **再レンダリングが完了して初めて** 新しい値が適用されます。

### 3️⃣ すべての値をStateにしないでください
変更されたときに **画面(UI)も一緒に変わる必要がある値** だけをStateにしてください。
そうでない値は通常の変数で十分です。

 \`\`\`jsx
 const
 let 
\`\`\` `},{id:"section3-summary",section:3,order:6,title:"セッション 3 まとめ：Stateを一気に整理",type:0,exp:15,time:6,content:`# 🏁 セクション 3 まとめ

おめでとうございます！ これでReactの最も重要な心臓部である **State** をマスターしました。

---

### ✅ 核心まとめ
- **State** はコンポーネントの記憶装置である。
- 状態変更は必ず **専用関数(setter)** を使用しなければならない。
- 状態が変わると **再レンダリング** が起こる。

---

これで自分のコンポーネントがデータを持てるようになりました。
では、このデータを **他のコンポーネントに渡す** にはどうすればいいでしょうか？
次のセクションの **Props** で確認しましょう！ 🎁`},{id:"props-passing-data",section:4,order:0,title:"Propsでデータを渡す",type:0,exp:20,time:12,content:`# 🎁 コンポーネントへの贈り物、Props

Reactにおいて **Props** は、親コンポーネントが子コンポーネントに渡す **データ** です。

> 簡単に言えば、親が子に与える **読み取り専用の値** です。

---

### ❓ なぜPropsが必要なのでしょうか？

ウェブサイトは数多くのコンポーネントの組み合わせで作られます。

 この時、コンポーネント同士で情報をやり取りして初めて画面が完成するのですが、その通路の役割を果たすのがPropsです。

---

### 👨‍👩‍👧 親 → 子の構造を理解する

\`\`\`jsx
// 親コンポーネント (App.jsx)
function App() {
  return <MyButton text="保存する" />;
}

// 子コンポーネント (MyButton.jsx)
function MyButton(props) {
  return <button>{props.text}</button>;
}
\`\`\`

**🖥️ ブラウザ出力結果:** 
> [保存する] 

 \`props.text\` 親(App)が送った「保存する」という値を子が受け取って使用します。
 子コンポーネントはこの値を **使用することだけができ、直接修正することはできません。** `},{id:"props-destructuring-intro",section:4,order:1,title:"Propsをより簡単に受け取る方法",type:0,exp:10,time:10,content:`# ✨ より綺麗なコード、分割代入

毎回 \`props.ooo\` と書く代わりに、JavaScriptの **分割代入** 構文を使うとコードがはるかに簡潔になります。

---

### 🔄 どのように変わりますか？

**従来の方法** 
\`\`\`jsx
function MyButton(props) {
  return <button>{props.text}</button>;
}
\`\`\`

**分割代入の方法** 
\`\`\`jsx
function MyButton({ text }) {
  return <button>{text}</button>;
}
\`\`\`

---

### 🚀 Propsが多いほど強力になります

例えば、親から受け取ったPropsが **100個、1000個** あると仮定してみてください。分割代入を使わない場合、皆さんはそれぞれのデータを使用するたびに毎回 **props.** を前に付けなければなりません。

- **可読性の低下** : コードが不必要に長くなり、一目で内容が入ってきません。
- **開発の疲労度** : 毎回 **props.** をタイピングする過程は非常に手間がかかり、ミスもしやすくなります。

**一方で、分割代入を使用すると？**
\`\`\`jsx
// props. を書く必要がなくなります！
function UserProfile({ name, age, email, address, job, hobby }) {
  return (
    <div>
      <h1>{name}</h1>
      <p>{age}歳 / {job}</p>
      <span>{email}</span>
    </div>
  );
}
\`\`\`

このように関数の引数の位置に直接 \`{ }\` を書いてあげると、まるで自分の部屋にある物をそのまま取り出して使うように、データ名だけで簡単に使用できます。読みやすく書きやすいコードを作るための第一歩です！`},{id:"props-pass-setstate",section:4,order:2,title:"関数もPropsとして渡せます",type:0,exp:20,time:15,content:`# ⚡ 親の関数を子に渡す

Propsには文字や数値だけでなく、 **関数も渡すことができます。** 親が持っているStateを子の方で変更したい場合にこの方法を使用します。

---

### ⌨️ 例で見てみよう

\`\`\`jsx
// 親コンポーネント
function App() {
  const [count, setCount] = useState(0);
  
  return <CounterButton onIncrease={() => setCount(count + 1)} />;
}

// 子コンポーネント
function CounterButton({ onIncrease }) {
  return <button onClick={onIncrease}>増加</button>;
}
\`\`\`

- **データ管理**: 親(App)が担当
- **アクション(クリック)**: 子(CounterButton)が担当
- 子でボタンを押すと、親から渡された関数が実行され、親のStateが変更されます！`},{id:"props-common-mistakes",section:4,order:3,title:"+ Props使用時の注意点",type:0,exp:10,time:8,content:`# ⚠️ Props使用時によくある間違い

### 1️⃣ Propsを直接修正しないでください
\`\`\`jsx
function Child(props) {
  props.text = "変更"; // ❌ エラー発生！
  return <div>{props.text}</div>;
}
\`\`\`
Propsは親からの「贈り物」のようなもので、子が勝手に変えることはできません。値を変えたい場合は、親に依頼（関数を実行）する必要があります。

### 2️⃣ PropsとStateの区別
- **コンポーネント自身が** 値を作って管理するなら？ 👉 **State** 
- **親から** 値を受け取って表示するだけなら？ 👉 **Props** 
### 3️⃣ 文字列以外の値は中括弧 { } を使用
\`\`\`jsx
<MyButton text="保存" /> // 文字列は引用符
<Counter count={10} /> // 数値、変数、関数は中括弧
\`\`\` `},{id:"quiz-props-definition",section:4,order:4,title:"Propsの定義クイズ",type:1,question:"次のうち、Propsの正しい説明はどれでしょうか？",options:["コンポーネントが自身で管理する状態値","親コンポーネントが子に渡す読み取り専用データ","子コンポーネントが直接修正できる値","HTMLタグの属性を意味するReact専用の構文"],correctAnswerIndex:1,explanation:"Propsは上位（親）コンポーネントが下位（子）コンポーネントに渡す読み取り専用のデータです。",exp:20,time:5},{id:"quiz-props-vs-state",section:4,order:5,title:"PropsとStateを区別する",type:2,question:"コンポーネントが直接管理し、変更時にレンダリングを誘発する値は何ですか？ (Props または State)",correctAnswer:"State,,state,,ステート,,状態,,状態値",explanation:"Stateはコンポーネント内部の状態であり、Propsは外部から受け取る設定値です。",exp:20,time:5},{id:"props-summary-review",section:4,order:6,title:"Propsまとめ ＆ 復習",type:0,exp:15,time:10,content:`# 🏁 セクション 4 まとめ

これでコンポーネント同士で会話する方法を学びました！ 

---

### ✅ 核心まとめ
- **Props** は親が子に与える **データ** である。
- 子はPropsを **修正できない。** (読み取り専用)
- **関数** もPropsとして渡して、子が親の状態を変更させることができる。
- \`{ text }\` のように **分割代入** を使うとコードが綺麗になる。

---

親から関数を受け取る方法まで分かったので、次は、その関数を「いつ」実行するかを決定する番です。
ユーザーのクリックや入力に反応する方法！ 次のセクションの **イベント(Event)** で会いましょう！ ⚡`},{id:"event-what-is-event",section:5,order:0,title:"Reactでのイベント(Event)とは？",type:0,exp:15,time:8,content:`# ⚡ ユーザーとの疎通、イベント(Event)

Reactにおいて **イベント** とは、ユーザーが画面と相互作用する際に発生するすべての行動を意味します。

### ❓ なぜイベントが重要なのでしょうか？

ユーザーがボタンを押したり文字を入力したりした時に画面が反応するようにするには、必ずイベントをキャッチしなければなりません。

> **ユーザーの行動** → イベント発生 → 関数の実行 → **Stateの変更** → 画面のアップデート

この流れの起点となるのが、まさにイベントです。

---

### 📌 Reactイベントの特徴

- HTMLイベントと似ていますが、 **キャメルケース(camelCase)** を使用します。
- 文字列ではなく **関数そのもの** を渡します。

\`\`\`jsx
<button onClick={handleClick}>クリック</button>
\`\`\` `},{id:"event-html-vs-react",section:5,order:1,title:"HTMLイベントとReactイベントの違い",type:0,exp:15,time:7,content:`# 🆚 HTML vs React イベント

ReactイベントはHTMLと似ているように見えますが、記述方式が厳格に異なります。

### ❌ HTML方式 (文字列を渡す)
\`\`\`html
<button onclick="handleClick()">クリック</button>
\`\`\`

### ✅ React方式 (関数を渡す)
\`\`\`jsx
<button onClick={handleClick}>クリック</button>
\`\`\`

---

### 🧠 主な違い

 **命名規則** 
 \`\`\`jsx
 //大文字に注意！
 onclick ❌
 onClick ✅
\`\`\`

 **伝達方式** \`"onClick"\` のように引用符の中にコードを書くのではなく、 \`{onClick}\` のように中括弧の中に **関数名** を入れます。

> Reactは「このボタンがクリックされたら、 **この関数を後で実行してね** 」とお願いする方式です。`},{id:"event-handler-function",section:5,order:2,title:"イベントハンドラ関数を作る",type:0,exp:20,time:10,content:`# 🛠️ イベントハンドラ(Event Handler)

イベントが発生した時に実行される関数を **イベントハンドラ** と呼びます。

\`\`\`jsx
function App() {
  const handleClick = () => {
    alert('ボタンがクリックされました！');
  };
  return <button onClick={handleClick}>アラートを表示</button>;
}
\`\`\`

**🖥️ ブラウザ出力結果:** 
> [アラートを表示] ボタン(クリック時にブラウザのアラート窓が登場)

---

### 💡 関数名の付け方のコツ
イベントハンドラの名前は、

\`\`\`jsx
 handleClick
 onChangeName
 handleSubmit 
\`\`\`

 上記のように、 **どのような動作をするのか** を明確に付けるのが慣習です。`},{id:"event-function-vs-execution",section:5,order:3,title:"関数を渡すか？実行するか？",type:0,exp:20,time:12,content:`# ⚠️ 最も多いミス：関数の呼び出し禁止！

Reactイベントを記述する際、最も頻繁に犯してしまうミスです。

### ❌ 間違ったコード
\`\`\`jsx
<button onClick={handleClick()}>クリック</button>
\`\`\`
これはクリックした時に実行されるのではなく、 **画面が描画された瞬間に関数が即座に実行** されてしまいます。

### ✅ 正しいコード
\`\`\`jsx
<button onClick={handleClick}>クリック</button>
\`\`\`
関数の後ろに \`()\` を付けずに、名前だけを渡す必要があります。

---

### 💡 アロー関数(Arrow Function)を使えば実行コードを入れてもOK！

「それでも、関数の中に他のコードや引数を入れて実行したいのですが？」という疑問が生じるかもしれません。現場でもこのような時に **アロー関数(Arrow Function)** が本当によく使われます。

\`\`\`jsx
<button 
  onClick={() => { 
    console.log("こんにちは！"); 
    handleClick(); 
  }}
>
  クリック
</button>
\`\`\`

**なぜこれは大丈夫なのですか？**
\`() => { ... }\` 形式の **アロー関数(Arrow Function)** 自体は、まだ実行されていない **「新しい関数の定義」** だからです。

- **handleClick()** : 関数を即座に実行し、その結果をonClickに渡します。（描画と同時に実行！）
- **() => { ... }** : 「後でこの **アロー関数(Arrow Function)** が呼び出されたら、その時中に書かれたコードを実行してね！」という **関数の袋** を渡しているのと同じです。

> 📌 **まとめ** : 関数名だけを書くか、 **アロー関数(Arrow Function)** で包んで渡しましょう。それがReactにおける正しい **「実行予約」** の方法です！`},{id:"event-state-update",section:5,order:4,title:"イベントでStateを変更する",type:0,exp:25,time:12,content:`# 🔄 イベントとStateの出会い

イベントの真の目的は、ユーザーの入力を受け取って **Stateを変更すること** です。

\`\`\`jsx
function Counter() {
  const [count, setCount] = useState(0);
  const handleIncrease = () => {
    setCount(count + 1); 
  };
  return (
    <div>
      <p>値: {count}</p>
      <button onClick={handleIncrease}>足す</button>
    </div>
  );
}
\`\`\`

**🖥️ ブラウザ出力結果** 
> 値: 0  
> [足す] クリック時に数字が1ずつ増加`},{id:"quiz-event-camelcase",section:5,order:5,title:"Reactイベント構文クイズ",type:1,exp:20,time:5,question:"Reactでボタンクリックイベントを正しく記述しているものはどれですか？",options:['onclick="handleClick()"',"onClick={handleClick}",'onClick="handleClick"',"onclick={handleClick()}"],correctAnswerIndex:1,explanation:"Reactイベントはキャメルケース(onClick)を使用し、中括弧の中に関数名を渡します。"},{id:"quiz-event-short-answer",section:5,order:6,title:"イベント概念短答クイズ",type:2,exp:20,time:5,question:"Reactイベントハンドラに渡すべきなのは、関数の「実行結果」でしょうか、「関数そのもの」でしょうか？",correctAnswer:"関数,,関数そのもの,,function,,function itself",explanation:"イベントが発生した時に初めて実行されるように、関数自体を渡す必要があります。"},{id:"event-summary-review",section:5,order:7,title:"セクション 5 まとめ：イベント整理",type:0,exp:15,time:7,content:`# 🏁 セクション 5 まとめ

これで皆さんは、ユーザーのクリックに反応する躍動感のあるコンポーネントを作ることができます！

### ✅ 核心まとめ
- Reactイベントは **camelCase** を使用する \`onClick\`
- イベントハンドラには **関数名** だけを渡す。 \`onClick={handleClick}\`
- イベントを通じて **Stateを変更** すると、画面が再描画される。

---

次のセクションでは、複数のデータを一度に扱う方法と **不変性(Immutable)** について学んでいきましょう。

いよいよ本格的にデータを扱う方法を学ぶ時間です！ 🚀`},{id:"list-intro",section:6,order:0,title:"リスト(List)とオブジェクト(Object)の基礎",type:0,exp:10,time:5,content:`# 📦 データをまとめる方法：配列とオブジェクト

Reactアプリで扱うデータのほとんどは、 **配列(List)** と **オブジェクト(Object)** の形式です。

### 1️⃣ 何が違うのでしょうか？
- **配列(List)** : [リンゴ, バナナ, イチゴ] のように **順序** があるデータの集まりです。
\`[リンゴ, バナナ, イチゴ]\`
- **オブジェクト(Object)** : { 名前: 'チョルス', 年齢: 20 } のように **意味(Key)** があるデータの集まりです。
\`{ 名前: 'チョルス', 年齢: 20 }\`

---

### 2️⃣ なぜReactで重要なのでしょうか？
- **配列** : Todoリストの一覧のように、 **繰り返される画面** を作る時に使用します。
- **オブジェクト** : 一人のユーザー情報のように、 **複合的なデータ** を管理する時に使用します。`},{id:"list-render",section:6,order:1,title:"配列データを画面に繰り返しレンダリングする",type:0,exp:15,time:12,content:`# 🔄 繰り返し処理のReact版：map()

配列を画面に表示する時は、JavaScriptの **\`map()\`** 関数を使用します。

### ✅ 例 
\`\`\`jsx
{fruits.map((fruit, index) => {
  return (
    <li key={index}>
      {fruit}
    </li>
  );
})}
\`\`\`

---

### 📌 なぜ key 属性が必須なのですか？

Reactは **key** を見て「あ、この項目が修正されたんだな」ということを判断します。まるで私たち一人一人に付与された **マイナンバー** のようなものです。

 **💡 お役立ちヒント：本当の固有IDはどのような形ですか？**
> 練習中は **index** を使うこともありますが、実際のサービスでは以下のように **絶対に重複しない固有の値** を使用します。
> - **データベースID**
  \` "user_01" \` \` "post_99" \`
> - **ランダム文字列**
  \` "abc-123-def" \`
> - **時間値(作成された瞬間の時間)**
  \` Date.now() \` 

> 単に **1, 2, 3...** のように順番に付けられる数字(**index**) は、リストの順番が入れ替わった時に、Reactがどの項目が本当に変わったのかを見つけられず、 **バグの原因** になります！`},{id:"list-reference-concept",section:6,order:2,title:"オブジェクトと配列：メモリアドレス(参照)の秘密",type:0,exp:15,time:10,content:`# 🔗 なぜ直接修正してはいけないのか？（参照を理解する）

ReactがStateが変わったかどうかを確認する方法は、意外にも単純です。 **「以前のアドレスと今のアドレスが同じかどうか」** を比較します。

### 1️⃣ プリミティブ変数 vs オブジェクト/配列
- **プリミティブ変数(数値、文字列)** : 値が変わればReactがすぐに気づきます。
- **オブジェクト/配列** : 実際のデータではなく、データが保存されている **「メモリアドレス(参照)」** を変数に持っています。

### 2️⃣ Reactが変化に気づかない理由
\`\`\`javascript
const [user, setUser] = useState({ name: 'タロウ' });

user.name = 'モモ'; // ❌ データは変わりましたが、「アドレス」はそのままでした。
setUser(user);      // 🧐 React：「アドレスが同じだな。何も変わっていないな！」
\`\`\`

### 💡 結論
Reactを反応させるには、中身だけを変えるのではなく、 **新しいアドレス（新しいオブジェクト）** を作って丸ごと入れ替える必要があります。その時に必要な道具が、まさに **スプレッド演算子** です。`},{id:"state-array-copy",section:6,order:3,title:"スプレッド演算子(...)：新しい参照を作る",type:0,exp:15,time:12,content:`# ✨ コピーして新しく作る：スプレッド演算子(...)

「参照の問題」を解決する最もスマートな方法です。既存のデータをそのままコピーして、 **新しいアドレスを持つ複製** を作るのです。

### 🔹 配列の更新パターン
\`\`\`jsx
const [todos, setTodos] = useState(['牛乳']);

// [...既存配列, 新項目] -> 既存のものを展開して新しい配列に入れる！
setTodos([...todos, '勉強']); 
\`\`\`

### 🔹 オブジェクトの更新パターン
\`\`\`jsx
const [user, setUser] = useState({ name: 'チョルス', age: 20 });

// { ...既存オブジェクト, 修正する属性 } -> 残りはコピーしてageだけ上書き！
setUser({ ...user, age: 21 });
\`\`\`

**🖥️ ブラウザの結果** 
> メモリアドレス(参照)が変わったため、Reactが即座に検知して画面を **再レンダリング** します。`},{id:"state-immutability",section:6,order:4,title:"不変性(Immutable)と状態管理",type:0,exp:15,time:8,content:`# 🛡️ データを守る原則、不変性

**不変性** とは、状態を直接変更しない原則を指します。

### ❓ 直接修正してはいけない理由
Reactは以前のデータと新しいデータの **メモリアドレス(参照)** を比較します。
アドレスが変わらなければ、データが変化したと判断されず、画面が再描画されません。

---

### 🛠️ 不変性を守るためのツール集

Reactの状態更新時、以下のツールは既存の配列を書き換えずに **新しい配列を返す** ため、安心して使用できます。

**1️⃣ スプレッド演算子**
\`\`\`javascript
[...] // 既存配列のコピーおよび項目の追加
{...} // 既存オブジェクトのコピーおよびプロパティの修正
\`\`\`

**2️⃣ 浅いコピーを返す主なメソッド**
\`\`\`javascript
.map()    // すべての要素を変形して新しい配列を生成
.filter() // 条件に合う要素だけを抽出して新しい配列を生成
.concat() // 複数の配列を結合して新しい配列を生成
.slice()  // 配열の一部分を切り取って新しい配列を生成

// (最新構文) オリジナルを書き換えないソートと逆順
.toSorted()
.toReversed()
\`\`\`

---

### ✅ 核心まとめ

 既存のデータを直接修正する 

\`\`\`jsx
 push   // データの追加 
 splice // データの追加 / 削除 
 sort   // データのソート 
\`\`\`

 などは、Reactでは一旦忘れてください！
常に上記のツールを活用して **新しいコピー** を作り、 **setState** に渡すのがReactの定石です。`},{id:"quiz-list-map",section:6,order:5,title:"配列レンダリングクイズ",type:2,question:"Reactで配列を画面に繰り返しレンダリングする時に使用するJavaScriptメソッドの名前を記述してください。",correctAnswer:"map,,map(),,マップ",explanation:"map() 関数は配列の各要素を回りながら、JSX要素に変換する役割を果たします。",exp:10,time:3},{id:"quiz-immutability-reason",section:6,order:6,title:"不変性の原理クイズ",type:1,question:"オブジェクトや配列を直接修正した時に、Reactが画面を再描画しない理由は何ですか？",options:["JavaScriptエンジンにエラーが発生するため","Reactは値ではなくメモリアドレス(参照)の変化を検知するため","直接修正するとデータが削除されるため","Reactがオブジェクトを嫌っているため"],correctAnswerIndex:1,explanation:"Reactは以前の状態と新しい状態の参照(アドレス)が異なる時のみ、アップデートを実行します。",exp:20,time:5},{id:"list-summary-review",section:6,order:7,title:"セクション 6 まとめ：リストと不변性",type:0,exp:20,time:7,content:`# 🏁 セクション 6 まとめ

React開発者なら一生守るべき **「不変性」** の基礎をマスターしました！

### ✅ 核心ポイント
- **map()** でリストを描画し、 **key** を必ず付与しよう。
- オブジェクト/配列は **メモリアドレス(参照)** を持つ。
- **スプレッド(...)** 演算子で常に **新しいアドレス** を持つコピーを作成してStateを更新しよう。

---

これで複数のデータを扱う方法まで分かりました。

データを見せる方法を学んだので、次はユーザーからデータを **「入力」** してもらう方法を学ぶ番です。
Todoリストの核心機能！ 次のセクションである **Section 7: Formイベント** で会いましょう！ 🚀`},{id:"form-intro",section:7,order:0,title:"なぜFormイベントを学ぶ必要があるのでしょうか？",type:0,exp:10,time:5,content:`# 📝 入力の始まり、Formイベント

これまではボタンを押す単純なクリックだけを学びましたが、実際のサービスではユーザーの **文字入力** を受け取らなければならないケースがはるかに多いです。

### 📌 _Form_ は、このような場所で使われます
- Todo内容の入力
- 検索ワードの入力
- ログインおよび会員登録

> **Todo-Listアプリの真の始まり** はボタンではなく、 **input + form** です。

このセクションでは、本格的なプロジェクト実習の前に必ず必要な入力処理の基礎を扱います。`},{id:"form-controlled-input",section:7,order:1,title:"inputの値はなぜStateで管理するのでしょうか？",type:0,exp:15,time:8,content:`# 🕹️ 自由自在に操る制御コンポーネント

Reactにおいてinputは単に文字が書かれる箱ではなく、 **Stateと連結された装置** です。これを **制御コンポーネント** と呼びます。

### ❓ なぜ入力ができないのでしょうか？
\`\`\`jsx
const [text, setText] = useState('');

<input value={text} /> // valueが空の値('')に固定されている！
\`\`\`
このように書くだけでは、キーボードを押しても文字が入力されません。 \`value\` がStateに完全に縛られているためです。

**解決策** : ユーザーが入力するたびにStateを更新する **イベント** がセットで必要です！`},{id:"form-onchange",section:7,order:2,title:"onChangeイベントで入力値を処理する",type:0,exp:20,time:12,content:`# 🔄 リアルタイム入力検知：onChange

ユーザーが文字を一字ずつ入力するたびに実行されるイベントが、まさに **onChange** です。 \`onChange\` 

 ### ✅ サンプルコードで確認 

\`\`\`jsx
function InputExample() {
  const [text, setText] = useState('');

  const handleChange = (e) => {
    setText(e.target.value); // 入力された文字をStateに保存！
  };

  return <input value={text} onChange={handleChange} />;
}
\`\`\`

**🖥️ ブラウザの流れ**
 キーボード入力 ➡️ onChange発生 ➡️  setText実行 ➡️  State変更 ➡️  画面(input)アップデート`},{id:"form-event-object",section:7,order:3,title:"イベントオブジェクト(e)とは何ですか？",type:0,exp:15,time:8,content:`# 📦 情報の詰め合わせ、イベントオブジェクト(e)

イベント関数を作る際に引数として受け取る **e** は、発生したイベントのすべての情報（どこでクリックされたか、どんな文字が入力されたかなど） が入ったオブジェクトです。

---

### 🏷️ 名前は自由、でも約束は必須！

関数の引数名を **e** にするか、 **event** にするかは、完全に開発者の自由です。
極端な話、 **apple** や **data** と名付けてもコードは全く同じように動作します。

しかし、世界中の開発者は慣習的に以下のような名前を使用します。
- **e** （最も一般的）
- **ev**
- **event**

**「なぜあえてその名前を使うのですか？」**
コードも一種の言語だからです。他の人が自分のコードを見た時に「あ、これはイベントオブジェクトを扱う変数なんだな！」と即座に理解できるように、 **約束されたキーワード** を使うのが開発者間の大切な慣例です。

---

### 🔑 最も重要なプロパティ一つ
**\`e.target.value\`**
現在のinputボックスに入力された **実際のテキスト** 値です。



今の段階では、これ一つだけ覚えておけば十分です！残りの複雑な情報は、後で必要になった時に一つずつ取り出して使えば大丈夫です。`},{id:"form-submit",section:7,order:4,title:"formとonSubmitイベント",type:0,exp:20,time:10,content:`# 📨 まとめて送信：form ＆ onSubmit

通常、一つの入力欄と一つのボタンをセットにしてデータを処理する時、 **<form>** タグを使用します。
 \`<form>\`

### ❓ なぜあえてformで囲むのでしょうか？
単に \`<div>\` でまとめてもいいのですが、 \`<form>\` を使用するとウェブブラウザが提供する **「送信(Submit)機能」** をそのまま活用できるからです。

### ✅ サンプルコードで確認
\`\`\`jsx
<form onSubmit={handleTodoSubmit}>
  <input />
  <button type="submit">追加</button>
</form>
\`\`\`

---

### 🧠 onSubmitはどのように動作しますか？
 **1.自動検知** 
 >ボタンをクリックするか、入力欄で **Enterキー** を押すと、ブラウザが「あ、このフォームを送信しようとしているんだな！」と判断します。
 
 **2.イベント発生** 
 >その瞬間、 **<form>** タグに設定されている **onSubmit** 関数が実行されます。

### 💡 ユーザーにとってのメリット
- **メリット 1** : いちいちクリックイベントを設定しなくても、ボタン一つで送信されます。
- **メリット 2** : マウスを使わず **Enterキー** を叩くだけでデータが送信されるため、ユーザー体験(UX)が大幅に向上します。

> 📌 つまり、 **form** はデータを送るための **一つのセット** だと考えると簡単です！`},{id:"form-prevent-default",section:7,order:5,title:"event.preventDefault()はなぜ必要なのでしょうか？",type:0,exp:20,time:10,content:`# 🛑 リロード停止！ preventDefault

HTMLの **form** は送信される瞬間、ページを **リロード** してしまうという非常に古い習性があります。

### ❌ リロードの問題
Reactアプリでリロードが起こると、せっかく蓄積した **Stateがすべて初期化** されてしまいます。

### ✅ 解決方法
\`\`\`jsx
const handleSubmit = (e) => {
  e.preventDefault(); // 「ブラウザよ、勝手にリロードしないで！」
  // この後に希望のロジックを記述
};
\`\`\`

ReactプロジェクトのすべてのForm送信関数には、このコードが **一行目** に入ると考えても間違いありません。`},{id:"form-submit-example",section:7,order:6,title:"入力 ＋ 送信の全体フロー例",type:0,exp:25,time:15,content:`# 🧩 ピースの組み合わせ：Form完成例

入力から送信、初期化までの全過程をひと目で確認しましょう。

\`\`\`jsx
function SimpleForm() {
  const [text, setText] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log("送信されたデータ:", text);
    setText(''); // 送信後に入力欄を空にする
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button type="submit">確認</button>
    </form>
  );
}
\`\`\`

このコードの構造が、皆さんがこれから作成する **Todo-Listの核心的な骨組み** になります！`},{id:"quiz-form-onchange",section:7,order:7,title:"inputイベントクイズ",type:1,exp:20,time:3,question:"inputの値が変わるたびに実行され、Stateを更新するために使用するReactイベントは何ですか？",options:["onClick","onSubmit","onChange","onInput"],correctAnswerIndex:2},{id:"quiz-form-prevent",section:7,order:8,title:"Formイベント短答クイズ",type:2,exp:25,time:4,question:"form送信時にブラウザのデフォルト動作（リロード）を防ぐために呼び出すメソッドは何ですか？",correctAnswer:"preventDefault,,e.preventDefault,,preventDefault(),,e.preventDefault()"},{id:"form-summary-review",section:7,order:9,title:"セクション 7 まとめ：Formイベント整理",type:0,exp:15,time:7,content:`# 🏁 セクション 7 まとめ

これで皆さんはユーザーの声（入力値）を受け取る準備が整いました！

### ✅ 核心まとめ
- **制御コンポーネント** : inputの値(**value**) をStateと同期させる。
- **onChange** : 入力するたびにStateをリアルタイムで変更する。
- **preventDefault()** : フォーム送信時の不要なリロードを防いでくれる。

---

お疲れ様でした！ もう練習用のサンプルはここまで。
次のセクションでは、これまで学んだすべてのピースを一つに合わせ、 **本物のTodo-Listプロジェクト** を開始します！ 💪🚀`},{id:"todo-intro-structure",section:8,order:0,title:"Todoプロジェクト開始 ＆ 構造の確認",type:0,exp:15,time:7,content:`# 🛠️ 本物のサービスを作ってみましょう

このセクションでは、これまで学んだすべてのパズルのピースを組み合わせて、 **Todo Listアプリ** をゼロから直接作ってみます。

### 📁 プロジェクト構成とファイル構造
最初からファイルを細かく分けるのではなく、 **App.jsx** で核心的な機能を先に完成させてから、部品（コンポーネント）を一つずつ分離していく予定です。

最終的に私たちが持つことになるファイル構造は以下の通りです。

\`\`\`bash
src/
 ┣ App.jsx (メイン親 - すべての状態管理)
 ┗ components/ (部品フォルダ)
    ┣ TodoForm.jsx (入力エリア)
    ┗ TodoList.jsx (リスト表示エリア)
\`\`\`

---

### 🧭 コンポーネント階層図のプレビュー

各コンポーネントがどのような役割を担うことになるのか、頭の中で描いてみてください。

\`\`\`text
App (状態管理の中心)
┃
┣━ TodoForm (入力窓)
┃  ┗━ [input] + [追加ボタン]
┃
┗━ TodoList (やる事リスト)
    ┗━ [削除ボタン]を含むリストアイテムたち
\`\`\`

---

💡 **学習ヒント**
> 最初から複数のファイルを行ったり来たりすると、流れを見失いやすくなります。
> 講義の流れに沿って、 **一つのファイルで機能を完成させ、それをコンポーネントとして抽出(Extracting)する過程** を経験してみてください。
> スタイル(CSS)よりも、 **データがどのように流れるのか(State ＆ Props)** だけに集中しましょう！`},{id:"todo-state-init",section:8,order:1,title:"Todoリストの状態を作る",type:0,exp:20,time:8,content:`# 骨組み作り：データ構造を決める

まず最初に、やる事リストを保存する **State** を作る必要があります。

### 🧠 Todoデータの形
各Todoは区別のために **ID** と **内容** が必要です。

\`\`\`jsx
const [todos, setTodos] = useState([
  { id: 1, text: 'Reactの基礎をマスターする' },
  { id: 2, text: 'Todoアプリを完成させる' },
]);
\`\`\`

---
### 📌 覚えておいてください
 リストは **配列 \`[ ]\`** 形式です。
 リストの中の一つ一つのデータは **オブジェクト \`{ }\`** 形式です。`},{id:"todo-render-list",section:8,order:2,title:"Todoリストを画面に出力する",type:0,exp:20,time:10,content:`# 🖼️ 画面に表示する：map()

作成したデータをユーザーに見せる番です。

\`\`\`jsx
<ul>
  {todos.map((todo) => (
    <li key={todo.id}>{todo.text}</li>
  ))}
</ul>
\`\`\`

---
### 📌 チェックポイント
- **map()** を使って配列の数だけ **<li>** を作ります。
- Reactが混乱しないように、固有のキー値を必ず入れてください！ \`key={todo.id}\``},{id:"todo-input-state",section:8,order:3,title:"入力フォームと入力状態を作る",type:0,exp:20,time:10,content:`# ✍️ 文字を入力してもらう

新しいやる事を入力するボックスと、その値を記憶するStateを作ります。

\`\`\`jsx
const [input, setInput] = useState('');

// ...中略

<input
  value={input}
  onChange={(e) => setInput(e.target.value)}
  placeholder="やる事を入力してください"
/>
\`\`\`

### 📌 なぜこのようにするのでしょうか？
> 入力欄の値(**value**) をState(**input**) と連結させることで、Reactが入力値を完璧に制御できるようになります。（これを **制御コンポーネント** と呼びましたよね！）`},{id:"todo-submit-add",section:8,order:4,title:"フォーム送信でTodoを追加する",type:0,exp:25,time:15,content:`# ➕ リストに新しい項目を追加する

いよいよ入力した文字を実際のリストに入れてみましょう。

\`\`\`jsx
const onSubmit = (e) => {
  e.preventDefault(); // リロード防止！

  const newTodo = {
    id: Date.now(), // 固有のID生成
    text: input,
  };

  setTodos([...todos, newTodo]); // 不変性を維持しながら追加！
  setInput(''); // 入力欄を空にする
};
\`\`\`

### 💡 ここでちょっと！ Date.now()とは何ですか？
IDはリストの中で各項目を区別する **マイナンバー** のようなものです。ですから、絶対に重複してはいけません。

- **Date** : JavaScriptで日付と時間を扱う道具です。
- **.now()** : この関数を実行する **「その刹那の時間」** をミリ秒(1/1000秒)単位の数値で返します。
- **なぜ使うのか？** : 時間は止まらずに流れるため、実行するたびに常に異なる数値が出ます。そのおかげで、別途データベースのない練習用プロジェクトにおいて、 **重複しない固有ID** を作る時に非常に重宝されます！

---

### ✅ これで可能になる機能
- 文字入力後にEnterまたはボタンクリック ➡️ 入力した値がリストにパッ！と現れます。
- Reactの **不変性の原則** のおかげで、画面が即座にアップデートされます。`},{id:"todo-split-components",section:8,order:5,title:"深掘り 1：コンポーネントに分離してみる",type:0,exp:20,time:15,content:`# ✂️ コードの掃除：ステップ別に部品を分ける

これまで **App.jsx** という一つの大きな部屋に、すべての家具を詰め込んできました。これからは役割に合わせて部屋（コンポーネント） を分け、引っ越しをしてみましょう。

---

### 🏗️ STEP 1: 新しいフォルダとファイルを作る
まず、部品を入れるための専用フォルダとファイルを作成します。
1️⃣ src フォルダの中に **components** という新しいフォルダを作ります。
2️⃣ components フォルダの中に **TodoForm.jsx** と **TodoList.jsx** ファイルを作ります。

![components-sample](${m})

---

### 🏗️ STEP 2: コードを切り取って移す
**App.jsx** にあったUIコードを、それぞれのファイルにコピーして貼り付けます。この時、各ファイルは独立した関数の形にする必要があります。

**1️⃣ TodoForm.jsx**
\`\`\`jsx
function TodoForm() {
  return (
    <form onSubmit={onSubmit}>
      <input 
        value={input} 
        onChange={onInputChange} 
        placeholder="やる事を入力してください" 
      />
      <button>追加</button>
    </form>
  );
}
export default TodoForm;
\`\`\`

**2️⃣ TodoList.jsx**
\`\`\`jsx
function TodoList() {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
export default TodoList;
\`\`\`

---

### 🏗️ STEP 3: App.jsxで部品を読み込む
作成した部品を **App.jsx** で使用できるように読み込み（Import） ます。

**現在の App.jsx の様子**
\`\`\`jsx
import { useState } from 'react';
// 1. 作成した部品をインポートします。
import TodoForm from './components/TodoForm'; 
import TodoList from './components/TodoList'; 

function App() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Reactの基礎をマスターする' },
    { id: 2, text: 'Todoアプリを完成させる' },
  ]);
  const [input, setInput] = useState('');

  const onSubmit = (e) => {
    e.preventDefault();
    const newTodo = { id: Date.now(), text: input };
    setTodos([...todos, newTodo]);
    setInput('');
  };

  return (
    <div>
      <h1>My Todo List</h1>
      {/* 2. 切り取った場所に部品を配置します。 */}
      <TodoForm /> 
      <TodoList />
    </div>
  );
}

export default App;
\`\`\`

### 💡 上記のステップに合わせてファイルを分離し、保存してみてください。
> おそらく画面が **真っ白になり、何も表示されなくなる** はずです。焦らないでください！ 開発者ツール（F12） のコンソールを開いてみると、 **"onSubmit is not defined"** といったエラーメッセージが表示されているはずです。 

コードをそのまま移したはずなのに、なぜ画面が消えてしまったのでしょうか？ 次の講義でその理由と解決策（Props） を一緒に探ってみましょう。`},{id:"todo-error-why",section:8,order:6,title:"深掘り 2：なぜエラーが発生するのでしょうか？",type:0,exp:25,time:12,content:`# 🧐 "onSubmit is not defined?"

コードを完璧にコピーして移したはずなのに、なぜブラウザのコンソールには **ReferenceError** （参照エラー） が表示されるのでしょうか？

![reference-error](${x})

### 🧠 原因：コンポーネントという独立した部屋

JavaScriptのすべての変数と関数は、 **宣言された領域（スコープ）** の中だけで生きています。簡単に言えば、各コンポーネントファイルは壁で仕切られた **「独立した部屋」** のようなものです。

以下のコードを見てください。Reactの立場からすると、どれほど困惑することでしょうか？

\`\`\`jsx
// 🏠 TodoForm.jsx の部屋
function TodoForm() {
  return (
    // ❓ 「onSubmitって誰ですか？ この部屋にはそんな人はいませんよ？」
    <form onSubmit={onSubmit}> 
    {/* ❓ 「inputはどこから来たデータですか？ 初耳です！」 */}
      <input value={input} />
      <button>追加</button>
    </form>
  );
}

// 🏠 TodoList.jsx の部屋
function TodoList() {
  return (
    <ul>
      {/* ❓ 「todosってまた誰ですか？ 聞いたこともない名前です！」 */}
      {todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
\`\`\`

- **App.jsx** : **todos** や **onSubmit** という家具が配置された大きな部屋です。
- **子コンポーネントたち** : 体だけで引っ越した新しい部屋です。以前の部屋にあった家具を一つも持ってきませんでした。

確かに親である **App** の部屋には家具がありますが、子の部屋からは壁に遮られて隣の部屋に何があるのか全く見えない状態なのです！

---

### 📦 解決策：データ配送サービス (Props)

コードをコピーして貼り付けるだけでは不十分です。親が持っている家具（データや関数） を、子の部屋へ公式に送ってあげる過程が必要です。

> **Props** は、親が子に送る **「宅配便の箱」** のようなものです。

次の講義で、この箱に **onSubmit** や **todos** を詰めて、子コンポーネントたちに安全に届けてみましょう！ いよいよ、扉を開けてデータをやり取りする時間です！`},{id:"todo-pass-props",section:8,order:7,title:"深掘り 3：データの配送と受け取り (Props)",type:0,exp:25,time:20,content:`# 🎁 データの配送と受け取り：Propsで接続完了

親（ **App.jsx** ） が投げた包みを子が受け取って初めてエラーが解決します。「配送（送る）」と「受領（受け取る）」の過程を分けて見ていきましょう。

---

### 1️⃣ [配送] 親がデータを送る (App.jsx)
親コンポーネントで子コンポーネントを呼び出す際、必要な家具（データ/関数） を属性として記述します。

\`\`\`jsx
// App.jsx 内部
<TodoForm input={input} setInput={setInput} onSubmit={onSubmit} />
<TodoList todos={todos} />
\`\`\`

---

### 2️⃣ [受領] 子がデータを受け取る (TodoForm, TodoList)
子は関数の **引数** の位置で **中括弧{ }** を開き、親が送った宅配便を取り出して使う必要があります。



#### 📂 TodoForm.jsx (入力担当)
\`\`\`jsx
// 📦 引数の位置で親が送った名前通りに受け取ります！
function TodoForm({ input, setInput, onSubmit }) {
  return (
    <form onSubmit={onSubmit}>
      <input 
        value={input} 
        onChange={(e) => setInput(e.target.value)} 
      />
      <button type="submit">追加</button>
    </form>
  );
}
export default TodoForm;
\`\`\`

#### 📂 TodoList.jsx (出力担当)
\`\`\`jsx
// 📦 親がくれた 'todos' を受け取って map を回します。
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
export default TodoList;
\`\`\`

---

### 🏠 3️⃣ 全体の接続構造 (App.jsx)
これで親コンポーネントですべての配送準備が整いました。

\`\`\`jsx
import { useState } from 'react';
import TodoForm from './components/TodoForm';
import TodoList from './components/TodoList';

function App() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Reactの基礎をマスターする' },
    { id: 2, text: 'Todoアプリを完成させる' },
  ]);
  const [input, setInput] = useState('');

  const onSubmit = (e) => {
    e.preventDefault();
    const newTodo = { id: Date.now(), text: input };
    setTodos([...todos, newTodo]);
    setInput('');
  };

  return (
    <div>
      <h1>My Todo List</h1>
      {/* 🚚 データの配送開始！ */}
      <TodoForm input={input} setInput={setInput} onSubmit={onSubmit} />
      <TodoList todos={todos} />
    </div>
  );
}
\`\`\`

> 🔑 **必ず覚えておいてください！**
> - 親はコンポーネントタグの中に **名前={値}** で送る！
> - 子は関数の括弧の中に **{ 名前 }** で受け取る！
 
これで真っ白だった画面が消え、アプリが正常に動作するようになります！ 🎉`},{id:"todo-delete-filter",section:8,order:8,title:"深掘り 4：Todo削除機能の実装",type:0,exp:30,time:20,content:`# 🗑️ 間違えて作った予定、スッキリ消去

追加と同じくらい重要な機能が **削除** です。今回は、自分がクリックした項目だけを選んで消す方法を学んでいきましょう。

---

### 1️⃣ [宣言] 削除関数を作る (App.jsx)

データ（State） を変更する権限は、データを持っている **親（App.jsx）** にあります。まず、親の部屋で削除ロジックを作成します。

\`\`\`jsx
// App.jsx 内部
const onDelete = (id) => {
  // filter: 「クリックしたidとは違うやつらだけ残して、新しいリストを作って！」
  const updatedTodos = todos.filter((todo) => todo.id !== id);
  setTodos(updatedTodos);
};

return (
  <div>
    {/* 🚚 作成した関数を TodoList に宅配（Props）として送ります！ */}
    <TodoList todos={todos} onDelete={onDelete} />
  </div>
);
\`\`\`

---

### 2️⃣ [受領と使用] 削除ボタンを付ける (TodoList.jsx)

親から受け取った **onDelete** の包みを開けて、ボタンに接続してみましょう。

\`\`\`jsx
// 📦 引数の位置で onDelete を受け取ります。
function TodoList({ todos, onDelete }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          {todo.text}
          {/* 🔘 ボタンクリック時、該当する todo の id を配達員（onDelete）に渡します。 */}
          <button onClick={() => onDelete(todo.id)}>削除</button>
        </li>
      ))}
    </ul>
  );
}
\`\`\`

---

### 🧠 コアロック：filter関数の理解

削除の核心は、 **「自分がクリックしたやつ以外をすべて残して！」** とReactに伝えることです。

- **浄水器のフィルター** を想像してみてください。汚染物質だけを取り除き、きれいな水だけを通しますよね？
- **条件文 (todo.id !== id)** が **真（True）** であるデータだけが生き残り、新しい配列に格納されます。削除ボタンを押したデータは、この条件で **偽（False）** となり脱落します。
- **不変性** : 既存の配列を直接修正するのではなく、条件を通過したデータで **「完全に新しい配列」** を作って入れ替える方式です。だからReactが変化を即座に感知できます。

---

### 🔑 まとめ：データの流れ
1. **App.jsx** : 削除ロジック（ **filter** ） を作り、子に送る。
2. **TodoList.jsx** : ボタンを押すと、親から受け取った関数を実行し、クリックされた **id** を渡す。

> おめでとうございます！ これで追加と削除がすべて可能な **本物のウェブサービス** の基本が整いました！ 👏`},{id:"todo-final-code",section:8,order:9,title:"深掘り 5：ついに完成！全体コードの確認",type:0,exp:10,time:5,content:`# 🏁 おめでとうございます！Todoアプリが完成しました。

部品ごとに分け、データを配送し、削除機能まで！ 私たちが一緒に作ったTodoアプリの全体構造をひと目で確認してみましょう。

---

### 📂 プロジェクト構造 (File Structure)
現在のあなたの \`src\` フォルダは、このような構成になっているはずです。



---

### 📝 ファイル別 全体コード

#### 1️⃣ App.jsx (メイン管制塔)
\`\`\`jsx
import { useState } from 'react';
import TodoForm from './components/TodoForm';
import TodoList from './components/TodoList';

function App() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Reactの基礎をマスターする' },
    { id: 2, text: 'Todoアプリを完成させる' },
  ]);
  const [input, setInput] = useState('');

  // 追加ロジック
  const onSubmit = (e) => {
    e.preventDefault();
    if (!input.trim()) return; // 空文字防止
    const newTodo = { id: Date.now(), text: input };
    setTodos([...todos, newTodo]);
    setInput('');
  };

  // 削除ロジック
  const onDelete = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <div className="app-container">
      <h1>My Todo List</h1>
      <TodoForm 
        input={input} 
        setInput={setInput} 
        onSubmit={onSubmit} 
      />
      <TodoList 
        todos={todos} 
        onDelete={onDelete} 
      />
    </div>
  );
}

export default App;
\`\`\`

#### 2️⃣ components/TodoForm.jsx (入力部品)
\`\`\`jsx
function TodoForm({ input, setInput, onSubmit }) {
  return (
    <form onSubmit={onSubmit}>
      <input 
        value={input} 
        onChange={(e) => setInput(e.target.value)} 
        placeholder="やる事を入力してください"
      />
      <button type="submit">追加</button>
    </form>
  );
}

export default TodoForm;
\`\`\`

#### 3️⃣ components/TodoList.jsx (リスト部品)
\`\`\`jsx
function TodoList({ todos, onDelete }) {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          {todo.text}
          <button onClick={() => onDelete(todo.id)}>削除</button>
        </li>
      ))}
    </ul>
  );
}

export default TodoList;
\`\`\`

---

> **💡 最終チェックリスト**
> ✔ 追加ボタンを押したとき、リストが正しく増えますか？
> ✔ 削除ボタンを押したとき、該当する項目だけが消えますか？
> ✔ 入力欄に文字を打つとき、エラーなく入力できますか？

すべてが完璧なら、あなたはもう **Reactの核心（コンポーネント、状態、Props）** をマスターしたことになります！ 🎉`},{id:"todo-section8-summary",section:8,order:10,title:"Section 8 まとめ：Todoアプリ完成",type:0,exp:20,time:7,content:`# 🎉 Reactで作った最初のサービス、完成おめでとうございます！

皆さんは今、実際に動作するサービスをReactで自ら作り上げました。頭の中だけで描いていた機能を **「自分のコード」** で証明した、とても価値のある瞬間です。

---

### 🧠 このセクションの重要ポイント (Review)
完成したコードには、Reactの真髄がすべて詰まっています。
- **状態管理** : **useState** を使い、ユーザーの入力とリストデータをリアルタイムで制御しました。
- **データの配送** : 部品（コンポーネント） を分け、 **Props** という宅配便でデータや関数をやり取りしました。
- **安全な削除** : オリジナルを傷つけない **不変性** の原則を守り、 **filter** でデータを削除しました。

---

### 🚀 次のレベルへ進むための挑戦課題
基本の骨組みは完成しました！ 次はこのアプリにあなただけの個性を吹き込む番です。

- **🎨 スタイリング** : CSSを活用して、Todoアプリに素敵なデザインを施してみましょう。
- **🛠️ 機能拡張** : 「全削除」ボタンを作ったり、やる事を「修正」 する機能に挑戦してみてください。
- **✅ 完了チェック** : やる事をクリックすると横線が引かれる「完了状態」 を追加してみるのはいかがでしょうか？

---

### 🤝 あなたの成果を自慢してください！
皆さんの個性が詰まったTodo Listをぜひ見てみたいです。完成した画面やコードを **コミュニティページ** で共有しましょう！ 仲間とコードを共有し、フィードバックを送り合う過程は、最も早く成長できる近道です。

本当にお疲れ様でした！ このTodoアプリが、皆さんのReactジャーニーにおける心強い第一歩となることを心から応援しています。 👏

\`\`\`jsx
// 皆さんの情熱を応援しています！
return (
  <Congratulations message="See you in the next level!" />
); 
// Made by Ryan
\`\`\``}],y=d("ko"),J=d(t=>t(y)==="ja"?T:b);function g(t){const[r,e]=f.useState(void 0);return A(()=>{if(t){e({width:t.offsetWidth,height:t.offsetHeight});const a=new ResizeObserver(o=>{if(!Array.isArray(o)||!o.length)return;const p=o[0];let n,i;if("borderBoxSize"in p){const s=p.borderBoxSize,c=Array.isArray(s)?s[0]:s;n=c.inlineSize,i=c.blockSize}else n=t.offsetWidth,i=t.offsetHeight;e({width:n,height:i})});return a.observe(t,{box:"border-box"}),()=>a.unobserve(t)}else e(void 0)},[t]),r}export{E as B,J as c,y as l,g as u};
